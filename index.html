<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>Semantics of Shape Expressions Schemas</title>
    <!-- link rel="stylesheet" href="css/wgio.min.css"/ ask Iovka -->
    <link rel="stylesheet" href="local.css"/>

    <script src='../primer/respec-w3c-common.js' async class='remove'></script>
    <script src="http://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>

    <script class='remove'>
      var respecConfig = {
      specStatus: "base",
      shortName:  "shex-semantics",
      editors: [
      {   name:       "Iovka Boneva",
      url:        "http://cristal.univ-lille.fr/~boneva/",
      company:    "University of Lille",
      companyURL: "http://www.univ-lille1.fr/" }
      ],
      // wg:           "Shape Expressions ",
      // wgURI:        "https://shex.io/",
      // wgPublicList: "public-shex-dev",
      // wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
      };
    </script>

    <script type="text/javascript"><!--
function prepareHighlight (highlightables, onClass, offClass, slide) {
  if (slide === undefined)
    slide = $("body .with-highlight").last();
  $.each( highlightables, function( index, value ){
    var elts = slide.find( "."+value );
    elts
  	.mouseenter(function() {
  	    elts.removeClass(offClass).addClass(onClass);
  	})
  	.mouseleave(function() {
  	    elts.removeClass(onClass).addClass(offClass);
  	})
    .addClass(offClass);
  })
}
-->
    </script>
  </head>
  
  <body>
    <section id="abstract">
      <p>
	This document describes the formal semantics of Shape Expressions (ShEx) schemas.
	The semantics is defined on a slight generalization of ShEx schemas, called the shapes language.
	The generalization allows for a more succinct abstract syntax on which the semantics of the shapes language is defined.
	In the generalization, 
	<ul>
	  <li>
	    a triple constraint uses a set of predicates, instead of a single predicate. This allows to get rid of the CLOSED and EXTRA modifiers of ShEx schemas;
	  </li>
	  <li>
	    a node constraint is an arbitrary set of RDF nodes. This allows to abstract from the various ways of defining a node constraint.
	  </li>
	</ul>
	The semantics of ShEx schemas is then defined as a translation to the shapes language.
      </p>
    </section>

    <section id="status">
      <p>
        The Shape Expressions language is expected to remain stable with the exception of:
      </p>
      <ul>
        <li>addition of a UNIQUE function</li>
        <li>addition of a mechanism for labeling productions</li>
        <li>clarification of semantic actions</li>
      </ul>
    </section>

	  <section id="notation">
	    <h2>Notation</h2>
      <p>
        The JSON Syntax serves as a serializable proxy for the ShEx abstract syntax.
        It consists of statements defining data structures and named members of those data structures.
        Each member has either a single type or two or more types that are a union (choice) of types.
        Each type is either a reference to another statement, an RDF type, or a <a href="http://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL literal term</a> (e.g. <code>numeric</code>)[[!sparql11-query]], or the template type <code>Set</code>, which signifies a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">logical set</a> of a type.
        Sets are unordered and duplicate members have no significance; the set <code>(1, 1, 2, 3, 5)</code> is the same as the set <code>(5, 1, 3, 2)</code>.
      </p>
      <p>
        Optional parameters are suffixed with a "<code>?</code>".
        For brevity, it is preferred that empty maps and lists are elided in serializations of ShExJ.
      </p>
      <p>In this notation,</p>

      <div class="shexj">
        <pre><a href="#dfn-Schema" class="obj">Schema</a> { <span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}? <span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">shapes</span>:{<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>-&gt;<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>}? }</pre>
      </div>
      <p>
        signifies that a <code>Schema</code> has five components called <code class="param">prefixes</code>, <code class="param">base</code>, <code class="param">startActs</code>, <code class="param">start</code>, <code class="param">shapes</code>:
      </p>
      <ul>
        <li><code class="param">prefixes</code> is an optional map from <a class="trmref" href="#dfn-PREFIX">PREFIX</a> to <a class="trmref" href="#dfn-IRI">IRI</a>.</li>
        <li><code class="param">base</code> is an optional <code>IRI</code>.</li>
        <li><code class="param">startActs</code> is an optional list of <a class="objref" href="#dfn-SemAct">SemAct</a>.</li>
        <li><code class="param">start</code> is an optional <a class="objref" href="#dfn-shapeExpr">shapeExpr</a>.</li>
        <li><code class="param">shapes</code> is an optional map from <a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> to <a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>.</li>
      </ul>

      <div class="shexj">
        <pre><a href="#dfn-shapeExpr" class="nob">shapeExpr</a> = <a class="objref" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | <a class="objref" href="#dfn-ShapeNot">ShapeNot</a> | <a class="objref" href="#dfn-NodeConstraint">NodeConstraint</a> | <a class="objref" href="#dfn-Shape">Shape</a> | <a class="objref" href="#dfn-ShapeRef">ShapeRef</a> | <a class="objref" href="#dfn-ShapeExternal">ShapeExternal</a> ;</pre>
      </div>
      <p>
        signifies that a <code>shapeExpr</code> is is one of seven object types: <a class="objref .shexj" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a>, ...:
      </p>

      <div class="shexj">
        <pre><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a> { <span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* }</pre>
      </div>
      <p>
        signifies that a <code>NodeConstraint</code> has a <code class="param">nodeKind</code> of one of the four literals followed by any number of <a class="objref .shexj" href="#dfn-xsFacet">xsFacet</a>.
      </p>

      <p>
        <code>IRI</code> and <code>BNode</code> are <a href="http://www.w3.org/TR/2014/REC-rdf11-mt-20140225/#notation">defined in RDF 1.1 Semantics</a>[[!rdf11-mt]].
        <a href="#dfn-Target"><code>Target</code></a>, <a href="#dfn-Shape"><code>Shape</code></a> and <a href="#dfn-Constraint"><code>Constraint</code></a> are defined terms within this document.
      </p>
      <p>
        JSON examples are rendered in a <span class="json">.json</span> CSS style.
        Partial examples include ranges in a <span class="comment">.comment</span> CSS style to indicate text which would be substituted in a complete example.
        For example  <span class="json">{ "type": "ShapeAnd", "shapeExprs": [ <span class="comment">SE<sub>1</sub></span>, <span class="comment">...</span> ] }</span> indicates that both <span class="comment">SE<sub>1</sub></span> and <span class="comment">...</span> would be substituted in a complete example.
      </p>
      <p>
        Terminals are JSON strings and are indicated by all-caps, e.g. <a class="trmref" href="#dfn-PREFIX">PREFIX</a> and <a class="trmref" href="#dfn-IRI">IRI</a>.
        For brevity RDF nodes are represented as JSON strings composed as:
      </p>
      <ul>
        <li>IRI: the lexical form of the IRI, e.g. <code class="json">"http://example.org/resource"</code></li>
        <li>BNode: the contatonation of "<code>_:</code>" and a blank node label, e.g. <code class="json">"_:blank3"</code></li>
        <li>literal: the concatonation of a U+0022 ('<code>"</code>'), the lexical form of the literal, U+0022, and the first matching of:
        <ul>
          <li>literal with type <code>http://www.w3.org/2001/XMLSchema#</code>: empty string, e.g. <code class="json">"abc"</code>.</li>
          <li>language tagged literal: U+0040 ('<code>@</code>') and the language tag, e.g. <code class="json">"\"hello world\"@en-US"</code></li>
          <li>datatyped literal: U+005E U+005E ('<code>^^</code>') and the lexical form of the datatype URI, e.g. <code class="json">"\"123\"^^http://www.w3.org/2001/XMLSchema#integer"</code></li>
        </ul></li>
      </ul>
      <div class="issue">
        <p>
          When stable, consider switching to the rdfjs task force's <a href="https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md#term">JSON representation</a> i.e.
        </p>
        <ul>
          <li>IRI: <code class="json">{ "termType": "NamedNode", "value": "http://example.org/resource" }</code></li>
          <li>BNode: <code class="json">{ "termType": "BlankNode", "value": "blank3" }</code></li>
          <li>literal:
          <ul>
            <li>literal with type <code>http://www.w3.org/2001/XMLSchema#</code>: <code class="json">{ "termType": "Literal", "value": "abc" }</code></li>
            <li>language tagged literal: <code class="json">{ "termType": "Literal", "value": "hello world", "language": "en-us", "datatype": "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" }</code></li>
            <li>datatyped literal: <code class="json">{ "termType": "Literal", "value": "123", "language": "", "datatype": "http://www.w3.org/1999/02/22-rdf-syntax-ns#integer" }</code></li>
          </ul></li>
        </ul>
      </div>
      <p>
        The term definitions given in this document rely on matching triple patterns in the form <code>(subject, predicate, object)</code> where each position may be supplied by a constant, a previously defined term, or the underscore "<code>_</code>", which represents a previously undefined element or wildcard.
        This corresponds to a <a href="http://www.w3.org/TR/sparql11-query/#defn_TriplePattern">SPARQL Triple Pattern</a> where each "_" is replaced by a unique blank node.
        Matching such a triple pattern against a graph is defined by <a href="http://www.w3.org/TR/sparql11-query/#BGPsparql">SPARQL Basic Graph Pattern Matching</a> (BFP) with a BGP containing only that triple pattern.
      </p>
      <!-- button id="toggleRDF">Toggle RDF ("r")</button> <button id="toggleExamples">Toggle Examples ("e")</button> <button id="toggleSquished">Render only abstract syntax ("a")</button -->

      <div class="example">
        <p>
          Results of validation are represented in a table associating node/shape pairs with a pass or fail and a reason for failure:
        </p>
      <table>
        <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
        <tr class="pass"><td>&lt;Shape1&gt;</td><td>&lt;node1&gt;</td><td>pass</td></tr>
        <tr class="fail"><td>&lt;Shape1&gt;</td><td>&lt;node2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
      </table>
      </div>
      <!--
	    <p>
        The following HTML tags and CSS classes are used to highlight the roles of text in this document:
	    </p>
	    <ul>
        <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li>
        <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li>
        <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li>
	      </ul>
      -->
	  </section>

    <section id="terminology">
      <h2>Terminology</h2>
      <p>Shape expressions are defined using terms from RDF semantics[[!rdf11-mt]]:</p>
      <ul>
        <li><a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-node">Node</a>: one of <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri" class="math">IRI</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-blank-node" class="math">BNode</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal" class="math">RDFLiteral</a></li>
        <li><a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-rdf-graph" class="math">Graph</a>: a set of <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-rdf-triple" class="math">Triples</a> of (<a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-subject" class="math">subject</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-predicate" class="math">predicate</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-object" class="math">object</a>)</li>
      </ul>
      <p>
	The following functions access the elements of an RDF graph <m>G</m> containing a node <m>n</m>:
	<ul>
	  <li>
	    <m>arcsOut(G, n)</m> is the set of triples in a graph <m>G</m> the subject <m>n</m>.
	  </li>
	  <li>
	    <m>predicatesOut(G, n)</m> is the set of predicates in <m>arcsOut(G, n)</m>.
	  </li>
	  <li>
	    <m>arcsIn(G, n)</m> is the set of triples in a graph <m>G</m> the object <m>n</m>.
	  </li>
	  <li>
	    <m>predicatesIn(G, n)</m> is the set of predicates in <m>arcsIn(G, n)</m>.
	  </li>
	  <li>
	    <m>neigh(G, n)</m> is the neighbourhood of the node <m>n</m> in the graph <m>G</m>.<br/><m>neigh(G, n) = arcsOut(G, n) ∪ arcsIn(G, n)</m>
	  </li>
	  <li>
	    <m>predicates(G, n)</m> is the set of predicates in <m>neigh(G, n)</m>.<br/><m>predicates(G, n) = predicatesOut(G, n) ∪ predicatesIn(G, n)</m>
	  </li>
	</ul>
      </p>

      <div class="Example">
	<p>
	  Consider the RDF graph <m>G</m> represented in Turtle:
	</p>

	<pre class="graph">
PREFIX ex: http://ex.example/#
PREFIX inst: http://inst.example/#
PREFIX foaf: http://xmlns.com/foaf/
PREFIX xsd: http://www.w3.org/2001/XMLSchema#

inst:Issue1 
    ex:state      ex:unassigned ;
    ex:reportedBy _:User2 .

_:User2
    foaf:name     "Bob Smith" ;
    foaf:mbox     &lt;mailto:bob@example.org&gt; .
        </pre>
        <p>
          <code>User2</code> is a BNode in this graph and is expressed here as <code>_:User2</code>.
        </p>
	<p>
	  There is one arc into <span class="pre">_:User2</span>; <m>arcsIn(G, <span class="pre">_:User2</span>)</m>:
  </p>
  <pre>
    inst:Issue1 ex:reportedBy  _:User2 .
  </pre>
	<p>
	  There are two arcs out of <span class="pre">_:User2</span>; <m>arcsOut(G, <span class="pre">_:User2</span>)</m>:
  </p>
  <pre>
    _:User2  foaf:name  "Bob Smith" .
    _:User2  foaf:mbox  &lt;mailto:bob@example.org&gt; .
  </pre>
	<p>
	  There are three arcs in the neighbourhood of <span class="pre">_:User2</span> set, <m>neigh(G, <span class="pre">_:User2</span>)</m>:
  </p>
  <pre>
    _:User2  foaf:name  "Bob Smith" .
    _:User2  foaf:mbox  &lt;mailto:bob@example.org&gt; .
    inst:Issue1 ex:reportedBy  _:User2 .
  </pre>
      </div>
    </section>

    <section id="shapes-language">
      <h2>The Shapes Language</h2>
      <p>
	A shapes schema defines a set of named constraints, called shapes.
	The name of a shape is also called shape label.
      </p>

      <section id="shapes-schema">
      <h3>Shapes Schema</h3>
      <p>
	      A shapes schema is captured in a <span class="jobjref"><a href="#dfn-Shema">Schema</a></span> object:
      </p>
      <div class="shexjTable">
        <table class="shexj">
  <tr class="obj"><th id="dfn-Schema" class="obj">Schema</th><td>{</td><td><span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}? <span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">shapes</span>:{<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>-&gt;<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>}? }</td></tr>
  <tr class="nob"><th id="dfn-shapeLabel" class="nob">shapeLabel</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-BNODE">BNODE</a> ;</td></tr>
        </table>
      </div>
      <p>
        where <span class="param">shapes</span> is a mapping from shape label to shape expression.
      </p>
      <div class="json">
        <pre>{ "type": "Schema", "shapes": {
    "http://schema.example/IssueShape": { <span class="comment">...</span> },
    "_:UserShape": { <span class="comment">...</span> },
    "http://schema.example/EmployeeShape": { <span class="comment">...</span> }
  }
}</pre>
      </div>
      </section>

      <section id="shape-map">
      <h3>Mapping From Nodes to Shapes</h3>

      <p>
	A <code>ShapeMap</code> is a set of node-label associations of the form <m>(node,S)</m> where <m>node</m> is an RDF node, and <m>S</m> is a shape label from a schema.
	A node-label association in a ShapeMap indicates that the node <m>node</m> satisfies the constraint given by the definition of the shape label <m>S</m>.
      </p>

      <div class="Example">
	<p>
	  Consider a shapes schema with shape labels <span class="json">"http://schema.example/IssueShape"</span>, <span class="json">"_:UserShape"</span>:
	</p>
      <div class="json">
        <pre>{ "type": "Schema", "shapes": {
    "http://schema.example/IssueShape": { <span class="comment">...</span> },
    "_:UserShape": { <span class="comment">...</span> },
    "http://schema.example/EmployeeShape": { <span class="comment">...</span> } } }</pre></div>
	<p>
	  An example ShapeMap is:
  </p>
  <div class="json">
    <pre>{ "http://inst.example/#Issue1": "http://schema.example/IssueShape,
  "_:User2", "_:UserShape",
  "_:User2", "http://schema.example/EmployeeShape" }</pre>
  </div>
      </div>
      </section>

      <section id="shape-expressions">
        <h3>Shape Expressions</h3>
        <p>
	        A shape expression is composed of four kinds of objects combined with a algebraic operators And, Or and Not:
        </p>
	      <ul>
	        <li>
	          a node constraint (<span class="jobjref"><a href="#dfn-NodeConstraint">NodeConstraint</a></span>) that defines the set of allowed values of a node.
	          In shapes schemas, a node constraint can be an arbitrary set that contains IRIs or RDFLiteral using different ways of restraining the type of a node: XML string and numeric facets, RDF node kind, and value sets.
	        </li>
	        <li>
	          a shape constraint (<span class="jobjref"><a href="#dfn-Shape">Shape</a></span>) that defines a constraint on the allowed neighbourhood of a node, that is, the allowed triples that contain this node as subject or object.
	        </li>
          <li>
            a shape reference (<span class="jobjref"><a href="#dfn-ShapeRef">ShapeRef</a></span>) identifies another shape in the schema.
          </li>
          <li>
            an extermal shape (<span class="jobjref"><a href="#dfn-ShapeExternal">ShapeExternal</a></span>) which is an extension mechanism to externally define e.g. functional shapes or prohibitively large value sets.
          </li>
	      </ul>
        <section id="shape-expressions-shexj">
          <h4>JSON Syntax</h4>

      <div class="shexjTable">
        <table class="shexj">
  <tr class="nob"><th id="dfn-shapeExpr" class="nob">shapeExpr</th><td>=</td><td><a class="objref" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | <a class="objref" href="#dfn-ShapeNot">ShapeNot</a> | <a class="objref" href="#dfn-NodeConstraint">NodeConstraint</a> | <a class="objref" href="#dfn-Shape">Shape</a> | <a class="objref" href="#dfn-ShapeRef">ShapeRef</a> | <a class="objref" href="#dfn-ShapeExternal">ShapeExternal</a> ;</td></tr>
  <tr class="obj"><th id="dfn-ShapeOr" class="obj">ShapeOr</th><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeAnd" class="obj">ShapeAnd</th><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeNot" class="obj">ShapeNot</th><td>{</td><td><span class="param">shapeExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a> }</td></tr>
  <tr class="obj"><th id="dfn-ShapeRef" class="obj">ShapeRef</th><td>{</td><td><span class="param">reference</span>:<a class="trmref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
  <tr class="obj"><th id="dfn-ShapeExternal" class="obj">ShapeExternal</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
        </table>
      </div>
      <div class="Example">
	<p>
	  Examples of shape expressions:
  </p>

  <div class="json">
    <pre>{ "type": "Shape", <span class="comment">...</span> }</pre>
  </div>
  <div style="clear:both;"> </div>
  <div class="json">
    <pre>{ "type": "ShapeAnd", "shapeExprs": [
  { "type": "NodeConstraint", <span class="comment">...</span> },
  { "type": "ShapeOr", "shapeExprs": [
    { "type": "ShapeRef", "reference": "http://schema.example/IssueShape" }
    { "type": "ShapeNot", "shapeExpr": { "type": "ShapeExternal" } }
    ] }
  ] }</pre>
  </div>
      </div>
      </section>
      <section id="value-expressions-semantics">
      <h4>Semantics</h4>
      <p>
        <span class="label" id="satisfies">satisfies</span>: The expression <code class="function">satisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code> indicates that a node <m>n</m> and graph <m>G</m> satisfy a shape expression <m>se</m> with shapeMap <m>m</m>.<br/>
        <span class="label" id="notSatisfies">notSatisfies</span>: Conversely, <code class="function">notSatisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code> indicates that <m>n</m> and <m>G</m> do not satisfy <m>se</m> with the given shapeMap <m>m</m>.
        <code class="function">notSatisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>_</m>)</code> indicates that no shapeMap would allow <m>n</m> and <m>G</m> to satisfy <m>se</m>.
      </p>
      <p>
        <code class="function">satisfies(<m>n</m>, <m>se</m>, <m>G</m>, <m>m</m>)</code> is true if and only if:
      </p>

      <ul>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a></span> and <code class="function">satisfies(<m>n</m>, <m>se</m>)</code> as described below in <a href="node-constraints">Node Constraints</a>.
        Note that testing if a node satisfies a node constraint does not require a graph or shapeMap.</li>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-Shape" class="obj">Shape</a></span> and <code class="function">satisfies(<m>n</m>, <m>se</m>)</code> as described below in <a href="#shapes-and-TEs">Shapes and Triple Expressions</a>.</li>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-ShapeOr" class="obj">ShapeOr</a></span> and there is some shape expression <m>se2</m> in <span class="param">shapeExprs</span> such that <code class="function">satisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a></span> and for every shape expression <m>se2</m> in <span class="param">shapeExprs</span>, <code class="function">satisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-ShapeNot" class="obj">ShapeNot</a></span> and for the shape expression <m>se2</m> at <span class="param">shapeExpr</span>, <code class="function">notSatisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-ShapeRef" class="obj">ShapeRef</a></span> and the <span class="jobjref"><a href="#dfn-Schema" class="obj">Schema</a></span>'s <span class="param">shapes</span> maps <span class="param">reference</span> to a shape expression <m>se2</m> and <code class="function">satisfies(<m>n</m>, <m>se2</m>, <m>G</m>, <m>m</m>)</code>.</li>
        <li><m>S</m> is a <span class="jobjref"><a href="#dfn-ShapeExternal" class="obj">ShapeExternal</a></span> and implementation-specific mechansims not defined in this specification indicate success.</li>
      </ul>

      <div class="Example">
	<p>
	  Given a three shape expressions <m>SE<sub>1</sub></m>, <m>SE<sub>2</sub></m>, <m>SE<sub>3</sub></m> in a <span class="jobjref"><a href="#dfn-Schema" class="obj">Schema</a></span> <m>Sch</m>, such that:
	</p>
  <ul>
    <li><code class="function">satisfies(<m>n</m>, <m>SE<sub>1</sub></m>, <m>G</m>, <m>m</m>)</code></li>
    <li><code class="function">satisfies(<m>n</m>, <m>SE<sub>2</sub></m>, <m>G</m>, <m>m</m>)</code></li>
    <li><code class="function">notSatisfies(<m>n</m>, <m>SE<sub>3</sub></m>, <m>G</m>, <m>m</m>)</code></li>
  </ul>
	<p>
    the following hold:
	</p>

	<ul>
    <li><code><div style="float:left;">satisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeAnd", "shapeExprs": [ <span class="comment">SE<sub>1</sub></span>, <span class="comment">SE<sub>2</sub></span> ] }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
    <li><code><div style="float:left;">satisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeOr", "shapeExprs": [ <span class="comment">SE<sub>1</sub></span>, <span class="comment">SE<sub>1</sub></span>, <span class="comment">SE<sub>3</sub></span> ] }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
    <li><code><div style="float:left;">notSatisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeNot", "shapeExpr": {
    { "type": "ShapeOr", "shapeExprs": [
        <span class="comment">SE<sub>1</sub></span>,
        { "type": "ShapeAnd", "shapeExprs": [ <span class="comment">SE<sub>2</sub></span>, <span class="comment">SE<sub>3</sub></span> ] }
      ] }
  } }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
	  </ul>

    <p>
      If <m>Sch</m>'s <span class="param">shapes</span> maps "<code>http://schema.example/shape1</code>" to <m>SE<sub>1</sub></m> then the following holds:
    </p>
	<ul>
    <li><code><div style="float:left;">satisfies(</div><div style="float:left;"><m>n</m>,<br/><div class="inline json"><pre>{ "type": "ShapeReference", "reference": "http://schema.example/shape1" }</pre></div>,<br/> <m>G</m>, <m>m</m>)</div></code><div style="clear:both;"></div></li>
	  </ul>
      </div>
      </section>
      </section>

      <section id="node-constraints">
        <h3>Node Constraints</h3>
        <div class="shexjTable">
          <table class="shexj">
  <tr class="obj"><th id="dfn-NodeConstraint" class="obj">NodeConstraint</th><td>{</td><td><span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <span class="param">datatype</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* <span class="param">values</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="nob"><th id="dfn-xsFacet" class="nob">xsFacet</th><td>=</td><td><a class="nobref" href="#dfn-stringFacet">stringFacet</a> | <a class="nobref" href="#dfn-numericFacet">numericFacet</a> ;</td></tr>
  <tr class="nob"><th id="dfn-stringFacet" class="nob">stringFacet</th><td>=</td><td>(<span class="param">"length"</span>|<span class="param">"minlength"</span>|<span class="param">"maxlength"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="param">pattern</span>:<a class="trmref" href="#dfn-STRING">STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericFacet" class="nob">numericFacet</th><td>=</td><td>(<span class="param">"mininclusive"</span>|<span class="param">"minexclusive"</span>|<span class="param">"maxinclusive"</span>|<span class="param">"maxexclusive"</span>):<a class="nobref" href="#dfn-numericLiteral">numericLiteral</a> </td></tr>
    <tr><th></th><td>|</td><td>(<span class="param">"totaldigits"</span>|<span class="param">"fractiondigits"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericLiteral" class="nob">numericLiteral</th><td>=</td><td><a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <a class="trmref" href="#dfn-DECIMAL">DECIMAL</a> | <a class="trmref" href="#dfn-DOUBLE">DOUBLE</a> ;</td></tr>
  <tr class="nob"><th id="dfn-objectValue" class="nob">objectValue</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-STRING">STRING</a> | <a class="trmref" href="#dfn-DATATYPE_STRING">DATATYPE_STRING</a> | <a class="trmref" href="#dfn-LANG_STRING">LANG_STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-valueSetValue" class="nob">valueSetValue</th><td>=</td><td><a class="nobref" href="#dfn-objectValue">objectValue</a> | <a class="objref" href="#dfn-Stem">Stem</a> | <a class="objref" href="#dfn-StemRange">StemRange</a> ;</td></tr>
  <tr class="obj"><th id="dfn-Stem" class="obj">Stem</th><td>{</td><td><span class="param">stem</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
  <tr class="obj"><th id="dfn-StemRange" class="obj">StemRange</th><td>{</td><td><span class="param">stem</span>:(<a class="trmref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-Wildcard">Wildcard</a>) <span class="param">exclusions</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Wildcard" class="obj">Wildcard</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
          </table>
        </div>
      </section>

      <section id="shapes-and-TEs">
        <h3>Shapes and Triple Expressions</h3>
      
      <p>
	      Triple expressions are used for defining patterns composed of triple constraints.
        Shapes associate triple expressions with flags indicating whether triples match if they do not correspond to triple constraints in the triple expression.
        A triple expression is composed of <span class="jobjref"><a href="#dfn-TripleConstraint">TripleConstraint</a></span> and <span class="jobjref"><a href="#dfn-Inclusion">Inclusion</a></span> objects composed with grouping and choice operators.
      </p>
      
      <section id="triple-expressions-abstract-syntax">
      <h4>JSON Syntax</h4>

      <div class="shexjTable">
        <table class="shexj">
  <tr class="obj"><th id="dfn-Shape" class="obj">Shape</th><td>{</td><td><!-- <span class="param">virtual</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>?  --><span class="param">closed</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">extra</span>:[<a class="trmref" href="#dfn-IRI">IRI</a>]? <span class="param">expression</span>:<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>?<!-- <span class="param">inherit</span>:[<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> -->]? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? }</td></tr>
  <tr class="nob"><th id="dfn-tripleExpr" class="nob">tripleExpr</th><td>=</td><td><a class="objref" href="#dfn-EachOf">EachOf</a> | <a class="objref" href="#dfn-SomeOf">SomeOf</a> | <a class="objref" href="#dfn-TripleConstraint">TripleConstraint</a> | <a class="objref" href="#dfn-Inclusion">Inclusion</a> ;</td></tr>
  <tr class="obj"><th id="dfn-EachOf" class="obj">EachOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-SomeOf" class="obj">SomeOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-TripleConstraint" class="obj">TripleConstraint</th><td>{</td><td><span class="param">inverse</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">negated</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">valueExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Inclusion" class="obj">Inclusion</th><td>{</td><td><span class="param">include</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
        </table>
      </div>
      <p id="inclusion-constraint">
        <span class="label">inclusion constraint</span>: An <span class="jobjref"><a href="#dfn-Inclusion">Inclusion</a></span> object's <span class="param">include</span> property MUST appear in the schema's <span class="param">shapes</span> map and the corresponding triple expression MUST be a <span class="jobjref"><a href="#dfn-Shape">Shape</a></span> with a <span class="param">tripleExpr</span>.
        The function <code>dereference(<span class="param">include</span>)</code> returns the shape's <span class="param">tripleExpr</span>.
      </p>

      <div class="Example">
        <p>
          Following is a valid inclusion:
        </p>
        <div class="json"><pre>{ "type":"Schema", "shapes": {
    "http://schema.example/PersonShape": {
      "type":"Shape", "expression": {
        "type": "TripleConstraint", "predicate": "http://xmlns.com/foaf/0.1/name"
      } },
    "http://schema.example/EmployeeShape": {
      "type":"Shape", "expression": { "type":"ShapeAnd", "shapeExprs": [
        { "type": "Inclusion", "include": "http://schema.example/PersonShape" }
        { "type": "TripleConstraint", "predicate": "http://schema.example/employeeNumber" }
] } } } }</pre></div>
        <p>
          This inclusion is invalid because there is no corresponding shape expression:
        </p>
        <div class="json"><pre>{ "type":"Schema", "shapes": {
    "http://schema.example/S1": {
      "type":"Shape", "expression": {
        "type": "Inclusion", "include": "http://schema.example/MissingShape"
} } } }</pre></div>
    <p>This inclusion is invalid because the referenced shape expression is not a simple shape with an <span class="param">expression</span>:</p>
    <div class="json"><pre>{ "type":"Schema", "shapes": {
    "http://schema.example/CustomerShape": {
      "type":"ShapeAnd", "shapeExprs": [ <span class="comment">...</span> ]
    },
    "http://schema.example/PreferredCustomerShape": {
      "type":"Shape", "expression": { "type":"ShapeAnd", "shapeExprs": [
        { "type": "Inclusion", "include": "http://schema.example/CustomerShape" }
        { "type": "TripleConstraint", "predicate": "http://schema.example/discount" }
] } } } }</pre></div>
      </div>
      <p id="negation-constraint">
        <span class="label">negation constraint</span>: An <span class="jobjref"><a href="#dfn-Inclusion">Inclusion</a></span> object's <span class="param">include</span> property MUST appear in the schema's <span class="param">shapes</span> map and the corresponding triple expression MUST be a <span class="jobjref"><a href="#dfn-Shape">Shape</a></span> with a <span class="param">tripleExpr</span>.
        The function <code>dereference(<span class="param">include</span>)</code> returns the shape's <span class="param">tripleExpr</span>.
      </p>

      <div class="issue">
        <p>
          This is a conservative protection from negation conundrums.
          <a href="">Stratified negation</a> would permit additional expressivity e.g.
        </p>
        <pre>&lt;S1&gt; NOT (NOT @&lt;S1&gt;)</pre>
      </div>

      </section>
      
      <section id="triple-expressions-semantics">
        <h4>Semantics</h4>
        <p>
          The <code><a href="#satisfies">satisfies</a></code> semantics for a <span class="jobjref"><a href="#dfn-Shape" class="obj">Shape</a></span> depend on a <code>matches</code> function <a href="#matches">defined below</a>.
          For a node <m>n</m>, shape <m>S</m>, graph <m>G</m>, and shapeMap <m>m</m>, <code class="function">satisfies(<m>n</m>, <m>S</m>, <m>G</m>, <m>m</m>)</code> if and only if:
        </p>
        <ul>
          <li>
            <code class="function">neigh(<m>G</m>, <m>n</m>)</code> can be partitioned into two sets <m>matched</m> and <m>remainder</m> such that <code class="function">matches(<m>matched</m>, <span class="param">expression</span>)</code>.
            If <span class="param">expression</span> is absent, <code class="function"><m>remainder</m> = neigh(<m>G</m>, <m>n</m>)</code>.<br/>
            Let <span class="label">outs</span> be the arcsOut in <m>remainder</m>:
            <code class="function"><m>outs</m> = <m>remainder</m> ∩ arcsOut(<m>G</m>, <m>n</m>)</code>.<br/>
            Let <span class="label">matchables</span> be the triples in <m>outs</m> whose predicate appears in a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> in <span class="param">expression</span>.
            If <span class="param">expression</span> is absent, <code class="function"><m>matchables</m> = <m>outs</m></code>.<br/>
            Let <span class="label">unmatchables</span> be the triples in <m>outs</m> which are not in <m>matchables</m>.
            <code class="function"><m>matchables</m> ∪ <m>unmatchables</m> = <m>outs</m></code>.
          </li>
          <li>
            There is no triple in <m>matchables</m> whose predicate does not appear in <span class="param">extra</span>.
          </li>
          <li><span class="param">closed</span> is false or <m>unmatchables</m> is empty.</li>
        </ul>
      <p>
	      <span class="label" id="matches">matches</span>: A triple expression is matched by a set of triples that come from the neighbourhood of a node in an RDF graph.
        The expression <code>matches(<m>T</m>, <m>expr</m>)</code> indicates that a set of triples <m>T</m> can satisfy these rules:
      </p>
      <ul>
        <li><m>expr</m> has a <span class="param">min</span> or a <span class="param">max</span> and there is some partition of <m>matched</m> into <m class="function">m<sub>1</sub></m>, <m>m<sub>2</sub></m>,… such that for every required repetition <m><sub>1</sub></m>, <m><sub>2</sub></m>,… ≤ <span class="param">min</span> in <span class="param">shapeExprs</span> and zero or more optional repetitions <m><sub><span class="param">min</span>+1</sub></m>, <m><sub><span class="param">min</span>+2</sub></m>,… ≤ <span class="param">max</span>, <code class="function">matches(<m>m<sub>n</sub></m>, <m>expr</m>)</code> by the remaining rules in this list.</li>
        <li><m>expr</m> is a <span class="jobjref"><a href="#dfn-SomeOf" class="obj">SomeOf</a></span> and there is some shape expression <m>se2</m> in <span class="param">shapeExprs</span> such that a <code class="function">matches(<m>T</m>, <m>expr</m>)</code>.</li>
        <li><m>expr</m> is an <span class="jobjref"><a href="#dfn-EachOf" class="obj">EachOf</a></span> and there is some partition of <m>matched</m> into <m>m<sub>1</sub></m>, <m>m<sub>2</sub></m>,… such that for every expression <span class="function"><m>expr<sub>1</sub></m>, <m>expr<sub>2</sub></m>,…</span> in <span class="param">shapeExprs</span>, <code class="function">matches(<m>m<sub>n</sub></m>, <m>expr<sub>n</sub></m>)</code>.</li>
        <li><m>expr</m> is a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> and </li>
        <li><m>expr</m> is an <span class="jobjref"><a href="#dfn-Inclusion" class="obj">Inclusion</a></span> and </li>
      </ul>
      <!-- p>
	Finally, a triple expression can be repeated by specifying a minimal cardinality that is a natural number, and a maximal cardinality that is a natural number of an unbounded value denoted as a star <m>*</m>. 
	A repeated triple expression <m>TExpr{min;max}</m> is satisfied by a set of triples if that set can be split into <m>k</m> disjoint subsets such that <m>min ≤ k ≤ max</m>, and each of these subsets matches the sub-expression <m>TExpr</m>.
      </p -->
    

      <div class="Example">
	<p>
	  Example of matching a triple constraint.
	</p>
<pre class="shex" style="float:left">
# if typing is such that
(:n1, &lt;SL_1&gt;) belongs to typing
(:n2, &lt;SL_2&gt;) does not belong to typing

# then 
typing, {(:n :p :n1)} &#x22A7; {:p}  &lt;SL_1&gt;
typing, {(:n :p :n1)} &#x22A7; {:p, :q}  &lt;SL_1&gt;
typing, {(:n :p :n2)} &#x22AD; {:p} &lt;SL_2&gt;
</pre>
<div style="clear:both;"> </div>
      </div>


      <div class="Example">
	<p>
	  Examples of satisfying an each-of triple expression.
	</p>
<pre class="shex" style="float:left">
# if typing is such that it contains the following node-label associations
(:n1, &lt;SL_1&gt;), (:n2, &lt;SL_2&gt;), (:n3, &lt;SL_1&gt;)

# then
typing, {(:n :p :n1), (:n :p :n2)}  &#x22A7;  {:p} &lt;SL_1&gt; ; {:q} &lt;SL_2&gt;
typing, {(:n :p :n1), (:n :p :n3)}  &#x22A7;  {:p} &lt;SL_1&gt; ; {:p} &lt;SL_1&gt;
typing, {(:n :p :n1)}               &#x22AD;  {:p} &lt;SL_1&gt; ; {:p} &lt;SL_1&gt
</pre>
<div style="clear:both;"> </div>
      </div>


      <div class="Example">
	<p>
	  Examples of satisfying a some-of triple expression.
	</p>
<pre class="shex" style="float:left">
# if typing is such that it contains the following node-label associations
(:n1, &lt;SL_1&gt;), (:n2, &lt;SL_2&gt;), (:n3, &lt;SL_1&gt;)

# then
typing, {(:n :p :n1)}               &#x22A7;   {:p} &lt;SL_1&gt; | {:q} &lt;SL_2&gt;
typing, {(:n :p :n1), (:n :p :n2)}  &#x22AD;   {:p} &lt;SL_1&gt; | {:q} &lt;SL_2&gt;
</pre>
<div style="clear:both;"> </div>
      </div>


      <div class="Example">
	<p>
	  Examples of satisfying a triple expression with some-of and each-of operators.
	</p>
<pre class="shex" style="float:left">
# if typing is such that it contains the following node-label associations
(:n1, &lt;SL_1&gt;), (:n2, &lt;SL_2&gt;), (:n3, &lt;SL_1&gt;) 

# then
typing, {(:n :p :n1)}                &#x22A7;  {:p} &lt;SL_1&gt; | {:q} &lt;SL_2&gt;
typing, {(:n :p :n1), (:n :p :n2)}   &#x22AD;  {:p} &lt;SL_1&gt; | {:q} &lt;SL_2&gt;
</pre>
<div style="clear:both;"> </div>
      </div>


      <div class="Example">
	<div class="with-highlight">
	  <p>
	    Consider the following triple expression and RDF graph.
	  </p>
<pre class="shex" style="float:left">
# graph G

ex:lp    rdf:type     foaf:Person;
         foaf:name    "Louisa Pavlova";
         foaf:mbox    "louisa@shex.org";
         foaf:mbox    "lpavlova@jobs.com";
         ex:memberOf  ex:gr2 .
ex:gr2   ex:leader    ex:lp .
ex:bug   ex:reportedBy  ex:lp .
</pre>
<pre class="shex" style="float:left">
# typing is such that it contains the following node-label associations

<span class="hl-all lowlight1">(n, &lt;SL_all&gt)  for all node n in G</span>
<span class="hl-rdftype lowlight1">(foaf:Person, &lt;SL_Person&gt;)</span>
<span class="hl-foafname lowlight1">("Louisa Pavlova", &lt;SL_string&gt;)</span>
<div class="hl-foafmbox lowlight1">("louisa@shex.org", &lt;SL_mbox_string&gt;)
("lpavlova@jobs.com", &lt;SL_mbox_string&gt;)</div><span class="hl-leader lowlight1">(ex:gr2, &lt;SL_Group&gt;)</span>

</pre>
<pre class="shex" style="float:left">
# triple expression TExpr

<span class="hl-rdftype lowlight1">{rdf:type}  &lt;SL_Person&gt;</span> ;
<span class="hl-foafname lowlight1">{foaf:name} &lt;SL_string&gt;</span> ;
<span class="hl-foafmbox lowlight1">( {foaf:mbox} &lt;SL_mbox_string&gt; {1;3} | {foaf:adress} &lt;SL_adr&gt; )</span> ;
<span class="hl-leader lowlight1">{^ex:leader} &lt;SL_Group&gt;</span> ;
<span class="hl-all lowlight1">C{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox, ^ex:leader} &lt;SL_all&gt; *</span>
</pre>
<pre class="shex" style="foaf:left">
# neigh(G, ex:lp), the neighbourhood of ex:lp in G

<span class="hl-rdftype lowlight1">ex:lp  rdf:type     foaf:Person .</span>
<span class="hl-foafname lowlight1">ex:lp  foaf:name    "Louisa Pavlova" .</span>
<div class="hl-foafmbox lowlight1">ex:lp  foaf:mbox    "louisa@shex.org" .
ex:lp  foaf:mbox    "lpavlova@jobs.com" .</div><span class="hl-leader lowlight1">ex:lp  ^ex:leader   ex:gr2</span>
<div class="hl-all lowlight1">ex:lp  ex:memberOf  ex:gr2
ex:lp  ^ex:reportedBy  ex:bug</div>
</pre>
<div style="clear:both;"> </div>

	  <p>
	    Then <span class="pre">typing, neigh(G, ex:lp) ⊢ TExpr</span>.
	    Move the mouse over the triples in <span class="pre">neigh(G, ex:lp)</span> to see which triples contribute to satisfy which of the sub-expressions of <span class="pre">TExpr</span>.
	  </p>
	</div>
	<script type="text/javascript">
	  <!--
	      prepareHighlight(["hl-rdftype","hl-foafname", "hl-foafmbox", "hl-leader", "hl-all"], "highlight1", "lowlight1");
	      prepareHighlight([], "highlight2", "lowlight2");
	      prepareHighlight([], "highlight3", "lowlight3");
	      prepareHighlight([], "highlight4", "lowlight4");
	    -->
	</script>
      </div>
      </section>
      </section>

      <section id="semantic-actions">
        <h3>Semantic Actions</h3>
        <div class="shexjTable">
          <table class="shexj">
  <tr class="obj"><th id="dfn-SemAct" class="obj">SemAct</th><td>{</td><td><span class="param">name</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">code</span>:<a class="trmref" href="#dfn-STRING">STRING</a>? }</td></tr>
          </table>
        </div>
      </section>

      <section id="annotations">
        <h3>Annotations</h3>
        <div class="shexjTable">
          <table class="shexj">
  <tr class="obj"><th id="dfn-Annotation" class="obj">Annotation</th><td>{</td><td><span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">object</span>:<a class="nobref" href="#dfn-objectValue">objectValue</a> }</td></tr>
          </table>
        </div>
      </section>
    </section>
      
      <section id="stratified-negation">
      <h3>Shapes Schemas with Stratified Negation</h3>
      <p>
	As we can see from the syntax, shape expressions can refer other shape definitions through a <as><a href="#dfn-ShapeRef">ShapeRef</a></as> within a <as><a href="#dfn-TripleConstraint">TripleConstraint</a></as>.
	In order to avoid undesirable interaction between recursion and the negation in value expressions, we consider shapes schemas with stratified negation only, as defined in the sequel.
      </p>
      
      <p>
	A <m>typing</m> of <m>G</m> by <m>Sch</m> is called correct if for all node-label association <m>(node, T)</m> in <m>typing</m>, it is the case that <m>typing, neigh(node) ⊢ def(T)</m>.
      </p>
      <p>
	We start by defining the dependency graph for a shapes schema, based on which we will define the stratification.
      </p>

      <p>
	For a schema <m>Sch = (SLabels, def)</m>, its dependency graph is a graph which set of nodes is <m>SLabels</m> and that has an edge from the shape label <m>L<sub>1</sub></m> to the shape label <m>L<sub>2</sub></m> if and only if <m>L<sub>2</sub></m> appears in the shape expression <m>def(L<sub>1</sub>)</m>.
	There are two kinds of edges in the graph:
	<ul>
	  <li>
	    a negative dependency edge <m>dep-(L<sub>1</sub>,L<sub>2</sub>)</m> if <m>L<sub>2</sub></m> appears in <m>def(L<sub>1</sub>)</m> under an odd number of occurrences of the <m>NOT</m> operator;
	  </li>
	  <li>
	    a positive dependency edge <m>dep+(L<sub>1</sub>,L<sub>2</sub>)</m> if <m>L<sub>2</sub></m> appears in <m>def(L<sub>1</sub>)</m> under an even number of occurrences of the <m>NOT</m> operator.
	  </li>
	</ul>	
      </p>
      <p>
	We say that the shapes schema <m>Sch</m> is with stratified negation if its dependency graph does not contain a cycle that goes through a <m>dep-</m> edge.
      </p>

      <div class="Example">
	<p>
	  The following is an example of a shapes schema and its dependency graph.
	</p>
<pre class="shex" style="float:left">
# a shapes schema

&lt;SL_all&gt; IRI ∪ RDFLiteral ∪ BNode
&lt;SL_1&gt;   NOT ({:c} &lt;SL_5&gt;)
&lt;SL_2&gt; := {:a} &lt;SL_4&gt; ; {:c} &lt;SL_5&gt; 
&lt;SL_3&gt; := NOT ({:c} &lt;SL_all&gt;) AND {:a} &lt;SL_2&gt;
&lt;SL_4&gt; := {:a} &lt;SL_3&gt;
&lt;SL_5&gt; := {:c} &lt;SL_all&gt;
</pre>
<pre class="shex" style="float:left">
# the edges of the dependency graph
# ---&gt; is a negative dependency edge
# -+-&gt; is a positive dependency edge

&lt;SL_1&gt; ---&gt; &lt;SL_5&gt;

&lt;SL_2&gt; -+-&gt; &lt;SL_4&gt;
&lt;SL_2&gt; -+-&gt; &lt;SL_5&gt;

&lt;SL_3&gt; ---&gt; &lt;SL_all&gt;
&lt;SL_3&gt; -+-&gt; &lt;SL_2&gt;

&lt;SL_4&gt; -+-&gt; &lt;SL_3&gt;

&lt;SL_5&gt; -+-&gt; &lt;SL_all&gt;
</pre>
<div style="clear:both;"> </div>
      </div>

      <p>
	If a schema is with stratified negation, then there exists a partition of the shape labels of the schema such that there does not exist a negative dependency edge between the shape labels of the same part of the partition.
	Moreover, the parts of the partition can be ranked in a way that all negative dependency edges always go from a partition with a higher rank to a partition with a lower rank.
	Such partitioning is called a stratification.
      </p>
      <p>
	More formally, if <m>Sch = (SLabels, def)</m> is a shapes schema with stratified negation, then there exists a natural number <m>k</m> and a partitioning function <m>strat: SLLabels &#8594; 1..k</m> that with every shape label from <m>SLabels</m> associates a natural number between <m>1</m> and <m>k</m>, called the stratum of that label. 
	Moreover, the partitioning function <m>strat</m> satisfies the following property: for all shape labels <m>L,L'</m> in <m>SLabels</m>, if <m>dep-(L,L')</m>, then <m>strat(L) &gt; strat(L')</m>, and if <m>dep+(L,L')</m>, then <m>strat(L) ≥ strat(L')</m>. 
	The partitioning function <m>strat</m> is called a stratification of <m>Sch</m>.
      </p>
      <p>
	A stratification guarantees the following property: the definition of a shape label can depend negatively only on shape labels that are in strictly lower stratums, and can depend positively only on shape labels that are on the same stratum or on a lower stratum.
	In particular, every circular dependency (the definition of a shape label depends on itself) enforces that all the intermediate shape labels are on the same stratum.
      </p>

      <div class="Example">
	<p>
	  A stratification for the schema on the previous example is:
	</p>
<pre class="shex" style="float:left">
strat(&lt;SL_2&gt;) = 3
strat(&lt;SL_3&gt;) = 3
strat(&lt;SL_4&gt;) = 3

strat(&lt;SL_1&gt;) = 2

strat(&lt;SL_5&gt;) = 1
strat(&lt;SL_all&gt;) = 1
</pre>
<div style="clear:both;"> </div>
	<p>
	  The shape labels  <span class="pre">&lt;SL_2&gt;, &lt;SL_3&gt;, &lt;SL_4&gt;</span> are on the same stratum.
	  One can see that there is a circular dependency between these three shape labels.
	  The two negative dependencies in that schema go from <span class="pre">&lt;SL_1&gt;</span> to <span class="pre">&lt;SL_5&gt;</span> (from stratum 2 to stratum 1), and from <span class="pre">&lt;SL_3&gt;</span> to <span class="pre">&lt;SL_all&gt;</span> (from stratum 3 to stratum 1).
	</p>
	<p>
	  Another possible stratification for that schema is to have only two stratums, and <span class="pre">&lt;SL_1&gt;</span> on the same stratum as <span class="pre">&lt;SL_2&gt;, &lt;SL_3&gt;, &lt;SL_4&gt;</span>.
	</p>
      </div>

      <p>
	Remark that it is easy to check whether a schema is with stratified negation: it is enough to construct the dependency graph, and check that it does not contain any cycle that goes through a negative dependency.
      </p>

      <section id="maximal-typing">
      <h3>Maximal Typing</h3>
      <p>
	A schema with stratified negation admits a unique typing defined here after.
	This typing is used for defining the semantics of shapes schemas: we say that a node in an RDF graph satisfies the constraint of a shape label if and only if the corresponding node-label association belongs to this particular typing.
	This typing is maximal as it forces to add in the typing every provable node-label association.
      </p>

      <p>
	Let <m>Sch = (SLabels, def)</m> be a schema with stratified negation and let <m>strat: TELabels &#8594; 1..k</m> be a stratification for <m>Sch</m>.
	Consider a graph <m>G</m>.
	We define a sequence <m>Sch<sub>1</sub>, ...., Sch<sub>k</sub></m> of sub-schemas of <m>Sch</m> following the stratification <m>strat</m>, as follows. 
	For all <m>i</m> in <m>1..k</m>, <m>Sch<sub>i</sub> = (SLabels<sub>i</sub>, def<sub>i</sub>)</m> where <m>SLabels<sub>i</sub></m> is the subset of <m>SLabels</m> composed of the shape labels on the stratums <m>1..i</m>.
	More formally, 
	<ul>
	  <li>
	    <m>SLabels<sub>i</sub> = strat<sup>-1</sup>(1) ∪ ... ∪ strat<sup>-1</sup>(i)</m>,
	  </li>
	  <li>
	    <m>def<sub>i</sub></m> is <m>def</m> restricted on <m>SLabels<sub>i</sub></m>.
	  </li>
	</ul>
	where <m>strat<sup>-1</sup></m> is the inverse of the stratification function, thus <m>strat<sup>-1</sup>(i)</m> is the set of all shape labels which stratum is <m>i</m>.
      </p>
      <p>
	It follows from this definition that <m>Sch<sub>k</sub></m> is equal to <m>Sch</m>.
      </p>

      <p>
	Then we define a sequence of typings <m>typing<sub>1</sub>, ..., typing<sub>k</sub></m> such that for all <m>i</m> in <m>1..k</m>, <m>typing<sub>1</sub></m> is the maximal typing for <m>Sch<sub>i</sub></m>.
	Formally, 
	<ul>
	  <li>
	    <m>typing<sub>1</sub></m> is the union of all correct <m>typing</m>s of <m>G</m> by <m>Sch<sub>1</sub></m>;
	  </li>
	  <li>
	    for <m>i</m> in <m>2..k</m>, <m>typing<sub>i</sub></m> is the union of all correct typings of <m>G</m> by <m>Sch<sub>i</sub></m> that coincide with <m>typing<sub>i-1</sub></m> on the <m>SLabels<sub>i-1</sub></m>.
	  </li>
	</ul>
      </p>
      
      <p>
	Note that because <m>Sch</m> is stratified and because of the way the sub-schemas <m>Sch<sub>i</sub></m> were defined, it is the case that all the typings <m>typing<sub>i</sub></m> are correct.
      </p>

      <p>
	The typing <m>typing<sub>k</sub></m> as defined above is called the maximal typing of <m>G</m> by <m>Sch</m>.
      </p>

      <div class="Example">
	<p>
	  TODO: an example of the sequence of typings
	</p>
      </div>
      </section>
    </section>
    
      <hr/>

    <section id="validation-for-shex">
      <h2>Validation of a Graph against a ShEx Schema</h2>

      <p>
	Let <m>Shex</m> be a ShEx schema with set <m>ShapeNames</m> of shape names.
	For a graph <m>G</m>, a validation problem is defined as a set <m>val</m> of node-label name associations.
	That is, <m>val</m> is a subset of <m>Nodes(G) × ShapeNames</m>.
	Then the validation problem consists in checking whether for every node-label name association <m>(node, sname)</m> in <m>val</m>, it is the case that <m>node</m> satisfies the constraint defined by <m>sname</m>.
      </p>

      <p>
	Formally, let <m>Sch</m> be the shapes schema that corresponds to <m>Shex</m>, and for every shape name <m>sname</m> in <m>Shex</m>, let <m>valConstr(sname)</m> be the corresponding value constraint name in <m>Sch</m>.
	Then the answer to the validation problem <m>val</m> is yes if and only if for all <m>(node, sname)</m> in <m>val</m>, it is the case that <m>typing, node ⊢ valConstr(sname)</m>, where <m>typing</m> is the maximal typing of <m>G</m> by <m>Sch</m>.
      </p>

      <p>
	Remark that the validation problem does not necessarily require to compute <m>typing</m> entirely.
	Only a portion of <m>typing</m> can be computed, starting from <m>val</m> and adding only the node-label associations that are necessary for proving, or disproving, the node-label name associations from <m>val</m>.
      </p>

    </section>




    <section id="shexj">
      <h2>ShEx JSON Syntax (ShExJ)</h2>
      <p>
        For instance, "<span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}?" indicates that prefixes is optional and if present is a mapping from the terminal <a class="trmref" href="#dfn-PREFIX">PREFIX</a> to the terminal <a class="trmref" href="#dfn-IRI">IRI</a>.
        "<span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>?" indicates that <span class="param">base</span> is optional and, if present, is an <a class="trmref" href="#dfn-IRI">IRI</a>.
      </p>
      <div class="shexjTable">
<table class="shexj">
  <tr class="obj"><th id="dfn-Schema" class="obj">Schema</th><td>{</td><td><span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}? <span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">shapes</span>:{<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>-&gt;<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>}? }</td></tr>
  <tr class="nob"><th id="dfn-shapeLabel" class="nob">shapeLabel</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-BNODE">BNODE</a> ;</td></tr>
  <tr class="nob"><th id="dfn-shapeExpr" class="nob">shapeExpr</th><td>=</td><td><a class="objref" href="#dfn-ShapeOr">ShapeOr</a> | <a class="objref" href="#dfn-ShapeAnd">ShapeAnd</a> | <a class="objref" href="#dfn-ShapeNot">ShapeNot</a> | <a class="objref" href="#dfn-NodeConstraint">NodeConstraint</a> | <a class="objref" href="#dfn-Shape">Shape</a> | <a class="objref" href="#dfn-ShapeRef">ShapeRef</a> | <a class="objref" href="#dfn-ShapeExternal">ShapeExternal</a> ;</td></tr>
  <tr class="obj"><th id="dfn-ShapeOr" class="obj">ShapeOr</th><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeAnd" class="obj">ShapeAnd</th><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
  <tr class="obj"><th id="dfn-ShapeNot" class="obj">ShapeNot</th><td>{</td><td><span class="param">shapeExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a> }</td></tr>
  <tr class="obj"><th id="dfn-Shape" class="obj">Shape</th><td>{</td><td><span class="param">virtual</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">closed</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">extra</span>:[<a class="trmref" href="#dfn-IRI">IRI</a>]? <span class="param">expression</span>:<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>? <span class="param">inherit</span>:[<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>]? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-ShapeRef" class="obj">ShapeRef</th><td>{</td><td><span class="param">reference</span>:<a class="trmref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
  <tr class="obj"><th id="dfn-ShapeExternal" class="obj">ShapeExternal</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
  <tr class="obj"><th id="dfn-SemAct" class="obj">SemAct</th><td>{</td><td><span class="param">name</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">code</span>:<a class="trmref" href="#dfn-STRING">STRING</a>? }</td></tr>
  <tr class="nob"><th id="dfn-tripleExpr" class="nob">tripleExpr</th><td>=</td><td><a class="objref" href="#dfn-EachOf">EachOf</a> | <a class="objref" href="#dfn-SomeOf">SomeOf</a> | <a class="objref" href="#dfn-TripleConstraint">TripleConstraint</a> | <a class="objref" href="#dfn-Inclusion">Inclusion</a> ;</td></tr>
  <tr class="obj"><th id="dfn-EachOf" class="obj">EachOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-SomeOf" class="obj">SomeOf</th><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Inclusion" class="obj">Inclusion</th><td>{</td><td><span class="param">include</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
  <tr class="obj"><th id="dfn-TripleConstraint" class="obj">TripleConstraint</th><td>{</td><td><span class="param">inverse</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">negated</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">valueExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-NodeConstraint" class="obj">NodeConstraint</th><td>{</td><td><span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <span class="param">datatype</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* <span class="param">values</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Annotation" class="obj">Annotation</th><td>{</td><td><span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">object</span>:<a class="nobref" href="#dfn-objectValue">objectValue</a> }</td></tr>
  <tr class="nob"><th id="dfn-xsFacet" class="nob">xsFacet</th><td>=</td><td><a class="nobref" href="#dfn-stringFacet">stringFacet</a> | <a class="nobref" href="#dfn-numericFacet">numericFacet</a> ;</td></tr>
  <tr class="nob"><th id="dfn-stringFacet" class="nob">stringFacet</th><td>=</td><td>(<span class="param">"length"</span>|<span class="param">"minlength"</span>|<span class="param">"maxlength"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="param">pattern</span>:<a class="trmref" href="#dfn-STRING">STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericFacet" class="nob">numericFacet</th><td>=</td><td>(<span class="param">"mininclusive"</span>|<span class="param">"minexclusive"</span>|<span class="param">"maxinclusive"</span>|<span class="param">"maxexclusive"</span>):<a class="nobref" href="#dfn-numericLiteral">numericLiteral</a> </td></tr>
    <tr><th></th><td>|</td><td>(<span class="param">"totaldigits"</span>|<span class="param">"fractiondigits"</span>):<a class="trmref" href="#dfn-INTEGER">INTEGER</a> ;</td></tr>
  <tr class="nob"><th id="dfn-numericLiteral" class="nob">numericLiteral</th><td>=</td><td><a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <a class="trmref" href="#dfn-DECIMAL">DECIMAL</a> | <a class="trmref" href="#dfn-DOUBLE">DOUBLE</a> ;</td></tr>
  <tr class="nob"><th id="dfn-objectValue" class="nob">objectValue</th><td>=</td><td><a class="trmref" href="#dfn-IRI">IRI</a> | <a class="trmref" href="#dfn-STRING">STRING</a> | <a class="trmref" href="#dfn-DATATYPE_STRING">DATATYPE_STRING</a> | <a class="trmref" href="#dfn-LANG_STRING">LANG_STRING</a> ;</td></tr>
  <tr class="nob"><th id="dfn-valueSetValue" class="nob">valueSetValue</th><td>=</td><td><a class="nobref" href="#dfn-objectValue">objectValue</a> | <a class="objref" href="#dfn-Stem">Stem</a> | <a class="objref" href="#dfn-StemRange">StemRange</a> ;</td></tr>
  <tr class="obj"><th id="dfn-Stem" class="obj">Stem</th><td>{</td><td><span class="param">stem</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
  <tr class="obj"><th id="dfn-StemRange" class="obj">StemRange</th><td>{</td><td><span class="param">stem</span>:(<a class="trmref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-Wildcard">Wildcard</a>) <span class="param">exclusions</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="obj"><th id="dfn-Wildcard" class="obj">Wildcard</th><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
  <tr style="background-color:white; border-left: thin solid white; border-right: thin solid white; "><th colspan="1" style="text-align: left;">Terminals</th><td></td><td>constrained by the <a href="#terminals">terminal rules in the compact syntax</a></td></tr>
<tr class="trm"><th id="dfn-PREFIX" class="trm">PREFIX</th><td>:</td><td><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></td></tr>
  <tr class="trm"><th id="dfn-IRI" class="trm">IRI</th><td>:</td><td>( [^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span> )* <span class="comment"># (<a class="grammarRef" href="#term-IRIREF">IRIREF</a> without the enclosing "&lt;&gt;"s)</span></td></tr>
  <tr class="trm"><th id="dfn-BNODE" class="trm">BNODE</th><td>:</td><td><a class="grammarRef" href="#term-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a></td></tr>
  <tr class="trm"><th id="dfn-BOOL" class="trm">BOOL</th><td>:</td><td>"true" | "false" <span class="comment"># a JSON boolean value</span></td></tr>
  <tr class="trm"><th id="dfn-INTEGER" class="trm">INTEGER</th><td>:</td><td><a class="grammarRef" href="#term-INTEGER">INTEGER</a> <span class="comment"># a JSON string matching the lexical form of an integer</span></td></tr>
  <tr class="trm"><th id="dfn-DECIMAL" class="trm">DECIMAL</th><td>:</td><td><a class="grammarRef" href="#term-DECIMAL">DECIMAL</a> <span class="comment"># a JSON string matching the lexical form of an decimal</span></td></tr>
  <tr class="trm"><th id="dfn-DOUBLE" class="trm">DOUBLE</th><td>:</td><td><a class="grammarRef" href="#term-DOUBLE">DOUBLE</a> <span class="comment"># a JSON string matching the lexical form of an double</span></td></tr>
  <tr class="trm"><th id="dfn-STRING" class="trm">STRING</th><td>:</td><td>'"' .* '"' <span class="comment"># a JSON string starting and ending with the U+0022 (") character</span></td></tr>
  <tr class="trm"><th id="dfn-DATATYPE_STRING" class="trm">DATATYPE_STRING</th><td>:</td><td>'"' .* '"' ( [^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span> )* <span class="comment"># a JSON string starting with U+0022 ("), followed by the lexical form of the string, then U+0022 U+005E U+005E ("^^) and the <a href="#dfn-IRI">IRI</a> of the datatype</span></td></tr>
  <tr class="trm"><th id="dfn-LANG_STRING" class="trm">LANG_STRING</th><td>:</td><td>'"' .* '"@' <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span> <span class="comment"># a JSON string starting with U+0022 ("), followed by the lexical form of the string, then U+0022 U+0040 ("@) and the <span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span></span></td></tr>
</table>
</div>

    </section>

    <section id="shexc">
      <h2>Parsing ShEx Compact syntax (ShExC)</h2>

      <div class="Example">
	<p>
	  Following is a ShEx schema written in ShExC with line numbers added at the left for reference.
	</p>


<pre class="shex">

      RREFIX ex:   &lt;http://ex.example/#&gt;
      PREFIX foaf: &lt;http://xmlns.com/foaf/&gt;
      PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
      PREFIX rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

1     &lt;IssueShape&gt; CLOSED EXTRA rdf:type
2     {                           
3         rdf:type [ex:Issue];
4         ex:state [ex:unassigned ex:assigned]; 
5                                            
6         ex:reportedBy @&lt;UserShape&gt;;   
7         ex:reportedOn xsd:dateTime;         
8         (                                   
9           ex:reproducedBy @&lt;EmployeeShape&gt;;  
10          ex:reproducedOn xsd:dateTime OR xsd:date 
11        )?;
12        ^ex:related @&lt;IssueShape&gt;*            
13    }
14
15    &lt;UserShape&gt; PATTERN "^http:/example.org/.*" {                     
16        (                                   
17           foaf:name xsd:string             
18         |                                  
19           foaf:givenName xsd:string+;      
20           foaf:familyName xsd:string
21        );     
22        foaf:mbox IRI              
23    }
24
25    &lt;EmployeeShape&gt; {        
26        foaf:phone IRI*;          
27        foaf:mbox IRI             
28    } AND {
29        ( foaf:phone PATTERN "^tel:\\+33"; 
30          foaf:mbox PATTERN "\\.fr$" )?;
31        ( foaf:phone PATTERN "^tel:\\+44"; 
32          foaf:mbox PATTERN "\\.uk$")?
33    }
</pre>
	<p>
	  We first explain some elements of the concrete syntax. 
	  A triple expression is surrounded by curly braces { and }.
	  The square braces delimit sets of values.
	  Parentheses are used as usual for defining the structre of an expression.
	  We use abbreviations for some intervals of min and max cardinality, namely, '+' is the interval [1;*], '*' is the interval [0;*], and '?' is the interval [0;1].
	</p>

	<p>
	  Then, the schema here above defines three shape labels: <span class="pre">&lt;IssueShape&gt;, &lt;UserShape&gt;, &lt;EmployeeShape&gt</span>.
	</p>
	<p>
	  The shape expression that defines the shape label <span class="pre">&lt;IssueShape&gt;</span> starts on line 1 after the shape label, and ends with the curly bracket on line 13.
	  It has an empty list of node constraints, and a single shape definition.
	  The shape definition has two modifiers, <m>CLOSED</m>, and <m>EXTRA</m>. 
	  The parameter of the <m>EXTRA</m> modifier is a singleton set that contains the property <span class="pre">rdf:type</span>.
	</p>
	<p>
	  The triple expression in the shape definition is given between the curly braces on lines 2 and 13.
	  It is an each-of expression composed of six sub-expressions, separated by semicolons. 
	  The sub-expressions are as follows:
	  <ul>
	    <li>
	      Four triple constraints on lines 3, 4, 6, 7.
	    </li>
	    <li>
	      Two repeated triple expressions, one on lines 8--11 with cardinality ? = [0;1], another one on line 12 with cardinality * = [0;*].
	    </li>
	  </ul>
	</p>

	<p>
	  We explain the different forms of triple constraint that appear in the definition of <span class="pre">&lt;IssueShape&gt;</span>, by explaining their property or their value expression.
	</p>

<pre>
1     &lt;IssueShape&gt; CLOSED EXTRA rdf:type
2     {                           
3         rdf:type [ex:Issue];                            # the property is rdf:type, 
                                                          # the value expression is a node constraint 
                                                          #    that is a singleton set containing the IRI ex:Issue

4         ex:state [ex:unassigned ex:assigned];           # the property is ex:state
5                                                         # the value expression is a set with two IRI,
                                                          #    ex:unassigned and ex:assigned

6         ex:reportedBy @&lt;UserShape&gt;;                     # the value expression is a ShapeExprRef 

7         ex:reportedOn xsd:dateTime;                     # the value expression is a the set of literal values 
                                                          #    that have XSD type xsd:dateTime
8         (                                   
9           ex:reproducedBy @&lt;EmployeeShape&gt;;  
10          ex:reproducedOn xsd:dateTime OR xsd:date      # the value expression is DisjunctiveValueExpr,
                                                          #    whose sub-expressions are sets of literal values
11        )?;
12        ex:related @&lt;IssueShape&gt;*            
13    }
</pre>

	<p>
	  We now explain a few other elements of the syntax.
	</p>

<pre>
15    &lt;UserShape&gt; PATTERN "^http:/example.org/.*" {                     
         ...
23    }
</pre>	

	<p>
	  The shape expression that defines <span class="pre">&lt;UserShape&gt;</span> is composed of one node constraint <span class="pre">PATTERN "^http:/example.org/.*"</span> and one shape definition between the curly braces lines 15 to 23.
	  The node constraint <span class="pre">PATTERN "^http:/example.org/.*"</span> defines the set of IRI that satisfy a pattern given by a regular expression.
	</p>

<pre>
25    &lt;EmployeeShape&gt; {        
        ...
28    } AND {
        ...
33    }
</pre>

	<p>
	  The shape expression that defines <span class="pre">&lt;EmployeeShape&gt;</span> is composed of zero node constrainst, and two shape definitions, separated by an <span class="pre">AND</span>.
	</p>
      </div>

      <div class="grammarTable">
<table border="0">

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      A ShEx document produces a schema.
      Semantic actions before the first <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shape expression declaration</a></span> are <span class="param"><a href="#dfn-Schema">startActs</a></span>.
      After the first <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shape expression declaration</a></span>, semantic actions are associated with the previous declaration.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-shexDoc" name="prod-shexDoc"></a>[<span class="prodNo">1</span>]   </td>
<td><code class="production prod">shexDoc</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-directive">directive</a></span>* ((<span class="prod"><a class="grammarRef" href="#prod-notStartAction">notStartAction</a></span> | <span class="prod"><a class="grammarRef" href="#prod-startActions">startActions</a></span>) <span class="prod"><a class="grammarRef" href="#prod-statement">statement</a></span>*)?</code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-Schema" class="obj">Schema</a></td><td>{</td><td>
<span class="param">prefixes</span>:{<a class="trmref" href="#dfn-PREFIX">PREFIX</a>-&gt;<a class="trmref" href="#dfn-IRI">IRI</a>}?
<span class="param">base</span>:<a class="trmref" href="#dfn-IRI">IRI</a>?
<span class="param">startActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]?
<span class="param">start</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>?
<span class="param">shapes</span>:{<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>-&gt;<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>}? }
</td></tr>
  <tr class="params"><td></td><td colspan="3"><ul>
  <li><span class="param">prefixes</span> comes from the <a class="grammarRef" href="#prod-prefixDecl">prefixDecl</a> production with the map key of <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> and the value of <span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span>.</li>
  <li><span class="param">base</span> comes from the <a class="grammarRef" href="#prod-baseDecl">baseDecl</a> production with the value of <span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span>.</li>
<li><span class="param">startActs</span> comes from <span class="prod"><a class="grammarRef" href="#prod-startActions">startActions</a></span> production.</li>
<li><span class="param">start</span> comes from the <span class="prod"><a class="grammarRef" href="#prod-start">start</a></span> production.</li>
<li><span class="param">shapes</span> come from the <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span> production.</li>
  </ul></td></tr>
<tr valign="baseline">
<td><a id="prod-directive" name="prod-directive"></a>[<span class="prodNo">2</span>]   </td>
<td><code class="production prod">directive</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-baseDecl">baseDecl</a></span> | <span class="prod"><a class="grammarRef" href="#prod-prefixDecl">prefixDecl</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-baseDecl" name="prod-baseDecl"></a>[<span class="prodNo">3</span>]   </td>
<td><code class="production prod">baseDecl</code></td>
<td>   ::=   </td>
<td><code class="content">"BASE" <span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-prefixDecl" name="prod-prefixDecl"></a>[<span class="prodNo">4</span>]   </td>
<td><code class="production prod">prefixDecl</code></td>
<td>   ::=   </td>
<td><code class="content">"PREFIX" <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-notStartAction" name="prod-notStartAction"></a>[<span class="prodNo">5</span>]   </td>
<td><code class="production prod">notStartAction</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-start">start</a></span> | <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-start" name="prod-start"></a>[<span class="prodNo">6</span>]   </td>
<td><code class="production prod">start</code></td>
<td>   ::=   </td>
<td><code class="content">"start" "=" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-startActions" name="prod-startActions"></a>[<span class="prodNo">7</span>]   </td>
<td><code class="production prod">startActions</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-codeDecl">codeDecl</a></span>+</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-statement" name="prod-statement"></a>[<span class="prodNo">8</span>]   </td>
<td><code class="production prod">statement</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-directive">directive</a></span> | <span class="prod"><a class="grammarRef" href="#prod-notStartAction">notStartAction</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-shapeExprDecl" name="prod-shapeExprDecl"></a>[<span class="prodNo">9</span>]   </td>
<td><code class="production prod">shapeExprDecl</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span> (<span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> | "EXTERNAL")</code></td>
</tr>
  <tr class="params"><td></td><td colspan="3">If the "<code>EXTERNAL</code>" keyword is present, <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span> returns a <a href="#dfn-ShapeExternal" class="obj">ShapeExternal</a> object:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-ShapeExternal" class="obj">ShapeExternal</a></td><td>{</td><td><span class="comment">/* empty */</span> }</td></tr>
  <tr class="params"><td></td><td colspan="3">otherwise <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span> returns <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span>.</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Shape expressions are logical combinations of shape atoms.
      Inline variants of shape expressions are used in <span class="prod"><a class="grammarRef" href="#prod-tripleConstraint">tripleConstraint</a></span>s and are not permitted to have annotations or semantic actions.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-shapeExpression" name="prod-shapeExpression"></a>[<span class="prodNo">10</span>]   </td>
<td><code class="production prod">shapeExpression</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeOr">shapeOr</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-inlineShapeExpression" name="prod-inlineShapeExpression"></a>[<span class="prodNo">14</span>]   </td>
<td><code class="production prod">inlineShapeExpression</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeOr">inlineShapeOr</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-shapeOr" name="prod-shapeOr"></a>[<span class="prodNo">11</span>]   </td>
<td><code class="production prod">shapeOr</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a></span> ("OR" <span class="prod"><a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a></span>)*</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-inlineShapeOr" name="prod-inlineShapeOr"></a>[<span class="prodNo">15</span>]   </td>
<td><code class="production prod">inlineShapeOr</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeAnd">inlineShapeAnd</a></span> ("OR" <span class="prod"><a class="grammarRef" href="#prod-inlineShapeAnd">inlineShapeAnd</a></span>)*</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a> matches one or more times, the result is a <a href="#dfn-ShapeOr" class="obj">ShapeOr</a> object with <span class="param">shapeExprs</span> containing the first <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-ShapeOr" class="obj">ShapeOr</a></td><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-shapeAnd">shapeAnd</a>.
</td></tr>
<tr valign="baseline">
<td><a id="prod-shapeAnd" name="prod-shapeAnd"></a>[<span class="prodNo">12</span>]   </td>
<td><code class="production prod">shapeAnd</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-shapeNot">shapeNot</a></span> ("AND" <span class="prod"><a class="grammarRef" href="#prod-shapeNot">shapeNot</a></span>)*</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-inlineShapeAnd" name="prod-inlineShapeAnd"></a>[<span class="prodNo">16</span>]   </td>
<td><code class="production prod">inlineShapeAnd</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeNot">inlineShapeNot</a></span> ("AND" <span class="prod"><a class="grammarRef" href="#prod-inlineShapeNot">inlineShapeNot</a></span>)*</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-shapeNot">shapeNot</a> matches one or more times, the result is a <a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a> object with <span class="param">shapeExprs</span> containing the first <a class="grammarRef" href="#prod-shapeNot">shapeNot</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-shapeNot">shapeNot</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a></td><td>{</td><td><span class="param">shapeExprs</span>:[<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-shapeNot">shapeNot</a>.
</td></tr>
<tr valign="baseline">
<td><a id="prod-shapeNot" name="prod-shapeNot"></a>[<span class="prodNo">13</span>]   </td>
<td><code class="production prod">shapeNot</code></td>
<td>   ::=   </td>
<td><code class="content">"NOT"? <span class="prod"><a class="grammarRef" href="#prod-shapeAtom">shapeAtom</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-inlineShapeNot" name="prod-inlineShapeNot"></a>[<span class="prodNo">17</span>]   </td>
<td><code class="production prod">inlineShapeNot</code></td>
<td>   ::=   </td>
<td><code class="content">"NOT"? <span class="prod"><a class="grammarRef" href="#prod-inlineShapeAtom">inlineShapeAtom</a></span></code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the left "<code>NOT</code>" matches, the result is a <a href="#dfn-ShapeNot" class="obj">ShapeNot</a> object with <span class="param">shapeExpr</span> containing the <a class="grammarRef" href="#prod-shapeAtom">shapeAtom</a>:</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-ShapeNot" class="obj">ShapeNot</a></td><td>{</td><td><span class="param">shapeExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a> }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the <a class="grammarRef" href="#prod-shapeAtom">shapeAtom</a>.
</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Shape atoms are shape references (indicated by "<code>@</code>"), definitions, or nested expressions.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-shapeAtom" name="prod-shapeAtom"></a>[<span class="prodNo">29</span>]   </td>
<td><code class="production prod">shapeAtom</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span>?<br/>
| <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span><br/>
| "(" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> ")"<br/>
| "."</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-inlineShapeAtom" name="prod-inlineShapeAtom"></a>[<span class="prodNo">30</span>]   </td>
<td><code class="production prod">inlineShapeAtom</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> <span class="prod"><a class="grammarRef" href="#prod-inlineShapeOrRef">inlineShapeOrRef</a></span>?<br/>
| <span class="prod"><a class="grammarRef" href="#prod-inlineShapeOrRef">inlineShapeOrRef</a></span> <span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span>?<br/>
| "(" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> ")"<br/>
| "."</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
<ul>
  <li>If the matching production inludes both a  <span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> and a <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span>, the result is a <a href="#dfn-ShapeAnd" class="obj">ShapeAnd</a> object with <span class="param">shapeExprs</span> containing the list of <span class="prod"><a class="grammarRef" href="#prod-nodeConstraint">nodeConstraint</a></span> and a <span class="prod"><a class="grammarRef" href="#prod-shapeOrRef">shapeOrRef</a></span>.</li>
  <li>If the "(" <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> ")" production matches, the result is the result of <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span>.</li>
  <li>If the <code>"."</code> production matches, the result is an empty shape: <code>{"type": "Shape"}</code>.</li>
</ul>
</td></tr>
<tr valign="baseline">
<td><a id="prod-shapeOrRef" name="prod-shapeOrRef"></a>[<span class="prodNo">46</span>]   </td>
<td><code class="production prod">shapeOrRef</code></td>
<td>   ::=   </td>
<td>   <code class="content">
<span class="prod"><a class="grammarRef" href="#prod-shapeDefinition">shapeDefinition</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-ATPNAME_LN">ATPNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-ATPNAME_NS">ATPNAME_NS</a></span> | "@" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span><br/>
</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-inlineShapeOrRef" name="prod-inlineShapeOrRef"></a>[<span class="prodNo">47</span>]   </td>
<td><code class="production prod">inlineShapeOrRef</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-inlineShapeDefinition">inlineShapeDefinition</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-ATPNAME_LN">ATPNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-ATPNAME_NS">ATPNAME_NS</a></span> | "@" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span><br/></code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
<ul>
  <li>If the <span class="prod"><a class="grammarRef" href="#prod-shapeDefinition">shapeDefinition</a></span> production matches, the result is <span class="prod"><a class="grammarRef" href="#prod-shapeDefinition">shapeDefinition</a></span>.</li>
  <li>Otherwise, the result is a <a href="#dfn-ShapeRef" class="obj">ShapeRef</a> object with <span class="param">reference</span> being the matching characters after the initial "<code>@</code>".</li>
</ul>
  <tr class="obj"><td></td><td href="#dfn-ShapeRef" class="obj">ShapeRef</td><td>{</td><td><span class="param">reference</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Node constraints identify a (possibly infinite) set of matching RDF nodes.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-nodeConstraint" name="prod-nodeConstraint"></a>[<span class="prodNo">31</span>]   </td>
<td><code class="production prod">nodeConstraint</code></td>
<td>   ::=   </td>
<td>   <code class="content">"LITERAL" <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-nonLiteralKind">nonLiteralKind</a></span> <span class="prod"><a class="grammarRef" href="#prod-stringFacet">stringFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-datatype">datatype</a></span> <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-valueSet">valueSet</a></span> <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>*<br/>
| <span class="prod"><a class="grammarRef" href="#prod-xsFacet">xsFacet</a></span>+</code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-NodeConstraint" class="obj">NodeConstraint</a></td><td>{</td><td><span class="param">nodeKind</span>:(<span class="literal">"iri"</span> | <span class="literal">"bnode"</span> | <span class="literal">"nonliteral"</span> | <span class="literal">"literal"</span>)? <span class="param">datatype</span>:<a class="trmref" href="#dfn-IRI">IRI</a>? <a class="nobref" href="#dfn-xsFacet">xsFacet</a>* <span class="param">values</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
<tr valign="baseline">
<td><a id="prod-nonLiteralKind" name="prod-nonLiteralKind"></a>[<span class="prodNo">32</span>]   </td>
<td><code class="production prod">nonLiteralKind</code></td>
<td>   ::=   </td>
<td><code class="content">"IRI" | "BNODE" | "NONLITERAL"</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-xsFacet" name="prod-xsFacet"></a>[<span class="prodNo">33</span>]   </td>
<td><code class="production prod">xsFacet</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-stringFacet">stringFacet</a></span> | <span class="prod"><a class="grammarRef" href="#prod-numericFacet">numericFacet</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-stringFacet" name="prod-stringFacet"></a>[<span class="prodNo">34</span>]   </td>
<td><code class="production prod">stringFacet</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-stringLength">stringLength</a></span> <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span><br/>
| "PATTERN" <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span><br/>
| "~" <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-stringLength" name="prod-stringLength"></a>[<span class="prodNo">35</span>]   </td>
<td><code class="production prod">stringLength</code></td>
<td>   ::=   </td>
<td><code class="content">"LENGTH" | "MINLENGTH" | "MAXLENGTH"</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-numericFacet" name="prod-numericFacet"></a>[<span class="prodNo">36</span>]   </td>
<td><code class="production prod">numericFacet</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-numericRange">numericRange</a></span> ( <span class="prod"><a class="grammarRef" href="#prod-numericLiteral">numericLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-string">string</a></span> "^^" <span class="prod"><a class="grammarRef" href="#prod-datatype">datatype</a></span> )<br/>
| <span class="prod"><a class="grammarRef" href="#prod-numericLength">numericLength</a></span> <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-numericRange" name="prod-numericRange"></a>[<span class="prodNo">37</span>]   </td>
<td><code class="production prod">numericRange</code></td>
<td>   ::=   </td>
<td><code class="content">"MININCLUSIVE" | "MINEXCLUSIVE" | "MAXINCLUSIVE" | "MAXEXCLUSIVE"</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-numericLength" name="prod-numericLength"></a>[<span class="prodNo">38</span>]   </td>
<td><code class="production prod">numericLength</code></td>
<td>   ::=   </td>
<td><code class="content">"TOTALDIGITS" | "FRACTIONDIGITS"</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph" style="border-left:thin solid white; border-right:thin solid white;">
  <tr><td rowspan="2" colspan="4">
    <p>
      Shape defintions associate a triple expression with a closed flag and a list of partially constrained (extra) predicates.
      Any predicate appearing in a triple expression is fully constrained unless it appears in the list of extras.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-shapeDefinition" name="prod-shapeDefinition"></a>[<span class="prodNo">18</span>]   </td>
<td><code class="production prod">shapeDefinition</code></td>
<td>   ::=   </td>
<td><code class="content">(<!-- <span class="prod"><a class="grammarRef" href="#prod-includeSet">includeSet</a></span> | --><span class="prod"><a class="grammarRef" href="#prod-extraPropertySet">extraPropertySet</a></span> | "CLOSED")* "{" <span class="prod"><a class="grammarRef" href="#prod-tripleExpression">tripleExpression</a></span>? "}" <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span>* <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-inlineShapeDefinition" name="prod-inlineShapeDefinition"></a>[<span class="prodNo">19</span>]   </td>
<td><code class="production prod">inlineShapeDefinition</code></td>
<td>   ::=   </td>
<td><code class="content">(<!-- <span class="prod"><a class="grammarRef" href="#prod-includeSet">includeSet</a></span> | --><span class="prod"><a class="grammarRef" href="#prod-extraPropertySet">extraPropertySet</a></span> | "CLOSED")* "{" <span class="prod"><a class="grammarRef" href="#prod-tripleExpression">tripleExpression</a></span>? "}"</code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-Shape" class="obj">Shape</a></td><td>{</td><td>
<!-- <span class="param">virtual</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? -->
<span class="param">closed</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>?
<span class="param">extra</span>:[<a class="trmref" href="#dfn-IRI">IRI</a>]?
<span class="param">expression</span>:<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>?
<!-- <span class="param">inherit</span>:[<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a>]? -->
<span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]?
<span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? }</td></tr>
  <tr class="params"><td></td><td colspan="3"><ul>
  <li><span class="param">closed</span> is true if the "<code>CLOSED</code>" choice was matched one or more times.</li>
  <li><span class="param">extra</span> is the set of IRIs matching the <a class="grammarRef" href="#prod-extraPropertySet">extraPropertySet</a> production.</li>
  <li><span class="param">expression</span> comes from the <a class="grammarRef" href="#prod-tripleExpression">tripleExpression</a> production.</li>
  <li><span class="param">annotations</span> is the set of <a class="objref" href="#dfn-Annotation">Annotation</a>s matching the <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span> production.</li>
  <li><span class="param">semActs</span> is the set of semantic actions matching the <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span> production.</li>
</ul>
  </td></tr>
<tr valign="baseline">
<td><a id="prod-extraPropertySet" name="prod-extraPropertySet"></a>[<span class="prodNo">20</span>]   </td>
<td><code class="production prod">extraPropertySet</code></td>
<td>   ::=   </td>
<td><code class="content">"EXTRA" <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span>+</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Triple expressions are arrangements of triple constraints.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-tripleExpression" name="prod-tripleExpression"></a>[<span class="prodNo">21</span>]   </td>
<td><code class="production prod">tripleExpression</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-someOfTripleExpr">someOfTripleExpr</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-someOfTripleExpr" name="prod-someOfTripleExpr"></a>[<span class="prodNo">21</span>]   </td>
<td><code class="production prod">someOfTripleExpr</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a></span> | <span class="prod"><a class="grammarRef" href="#prod-multiElementSomeOf">multiElementSomeOf</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-multiElementSomeOf" name="prod-multiElementSomeOf"></a>[<span class="prodNo">22</span>]   </td>
<td><code class="production prod">multiElementSomeOf</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a></span> ("|" <span class="prod"><a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a></span>)+</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a> matches one or more times, the result is a <a href="#dfn-SomeOf" class="obj">SomeOf</a> object with <span class="param">expressions</span> containing the first <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-SomeOf" class="obj">SomeOf</a></td><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-groupTripleExpr">groupTripleExpr</a>.
</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-innerTripleExpr" name="prod-innerTripleExpr"></a>[<span class="prodNo">23</span>]   </td>
<td><code class="production prod">innerTripleExpr</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-multiElementGroup">multiElementGroup</a></span> | <span class="prod"><a class="grammarRef" href="#prod-multiElementSomeOf">multiElementSomeOf</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-groupTripleExpr" name="prod-groupTripleExpr"></a>[<span class="prodNo">24</span>]   </td>
<td><code class="production prod">groupTripleExpr</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-singleElementGroup">singleElementGroup</a></span> | <span class="prod"><a class="grammarRef" href="#prod-multiElementGroup">multiElementGroup</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-singleElementGroup" name="prod-singleElementGroup"></a>[<span class="prodNo">25</span>]   </td>
<td><code class="production prod">singleElementGroup</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a></span> ";"?</code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-multiElementGroup" name="prod-multiElementGroup"></a>[<span class="prodNo">26</span>]   </td>
<td><code class="production prod">multiElementGroup</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a></span> (";" <span class="prod"><a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a></span>)+ ";"?</code></td>
</tr>
<tr class="params"><td></td><td colspan="3">
If the right <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a> matches one or more times, the result is a <a href="#dfn-EachOf" class="obj">EachOf</a> object with <span class="param">expressions</span> containing the first <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a> followed by the ordered list from the second <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a>:
</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-EachOf" class="obj">EachOf</a></td><td>{</td><td><span class="param">expressions</span>:[<a class="nobref" href="#dfn-tripleExpr">tripleExpr</a>] }</td></tr>
<tr class="params"><td></td><td colspan="3">
otherwise the result is the left <a class="grammarRef" href="#prod-unaryTripleExpr">unaryTripleExpr</a>.
</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-unaryTripleExpr" name="prod-unaryTripleExpr"></a>[<span class="prodNo">27</span>]   </td>
<td><code class="production prod">unaryTripleExpr</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-productionLabel">productionLabel</a></span>? (<span class="prod"><a class="grammarRef" href="#prod-tripleConstraint">tripleConstraint</a></span> | <span class="prod"><a class="grammarRef" href="#prod-bracketedTripleExpr">bracketedTripleExpr</a></span>)<br/>
| <span class="prod"><a class="grammarRef" href="#prod-include">include</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-bracketedTripleExpr" name="prod-bracketedTripleExpr"></a>[<span class="prodNo">28</span>]   </td>
<td><code class="production prod">bracketedTripleExpr</code></td>
<td>   ::=   </td>
<td><code class="content">"(" <span class="prod"><a class="grammarRef" href="#prod-innerTripleExpr">innerTripleExpr</a></span> ")" <span class="prod"><a class="grammarRef" href="#prod-cardinality">cardinality</a></span>? <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span>* <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-productionLabel" name="prod-productionLabel"></a>[<span class="prodNo">63</span>]   </td>
<td><code class="production prod">productionLabel</code></td>
<td>   ::=   </td>
<td><code class="content">"$" (<span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#prod-blankNode">blankNode</a></span>)</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Triple constraints are matched against RDF triples.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-tripleConstraint" name="prod-tripleConstraint"></a>[<span class="prodNo">39</span>]   </td>
<td><code class="production prod">tripleConstraint</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-senseFlags">senseFlags</a></span>? <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span> <span class="prod"><a class="grammarRef" href="#prod-inlineShapeExpression">inlineShapeExpression</a></span> <span class="prod"><a class="grammarRef" href="#prod-cardinality">cardinality</a></span>? <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span>* <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span></code></td>
</tr>
<tr class="obj"><td></td><td><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></td><td>{</td><td><span class="param">inverse</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">negated</span>:<a class="trmref" href="#dfn-BOOL">BOOL</a>? <span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">valueExpr</span>:<a class="nobref" href="#dfn-shapeExpr">shapeExpr</a>? <span class="param">min</span>:<a class="trmref" href="#dfn-INTEGER">INTEGER</a>? <span class="param">max</span>:(<a class="trmref" href="#dfn-INTEGER">INTEGER</a> | <span class="literal">"*"</span>)? <span class="param">semActs</span>:[<a class="objref" href="#dfn-SemAct">SemAct</a>]? <span class="param">annotations</span>:[<a class="objref" href="#dfn-Annotation">Annotation</a>]? }</td></tr>

  <tr class="params"><td></td><td colspan="3"><ul>
  <li><span class="param">inverse</span> is true if the <span class="prod"><a class="grammarRef" href="#prod-senseFlags">senseFlags</a></span> matched "<code>^</code>".</li>
  <li><span class="param">negated</span> is true if the <span class="prod"><a class="grammarRef" href="#prod-senseFlags">senseFlags</a></span> matched "<code>!</code>".</li>
  <li><span class="param">predicate</span> comes from the <a class="grammarRef" href="#prod-predicate">predicate</a> production.</li>
  <li><span class="param">valueExpr</span> comes from the <a class="grammarRef" href="#prod-inlineShapeExpression">inlineShapeExpression</a> production. It it is an empty shape <code>{"type": "Shape"}</code>, <span class="param">valueExpr</span> is not assigned.</li>
  <li><span class="param">min</span> comes from the <a class="grammarRef" href="#prod-cardinality">cardinality</a> production.</li>
  <li><span class="param">max</span> comes from the <a class="grammarRef" href="#prod-cardinality">cardinality</a> production.</li>
  <li><span class="param">annotations</span> is the set of <a class="objref" href="#dfn-Annotation">Annotation</a>s matching the <span class="prod"><a class="grammarRef" href="#prod-annotation">annotation</a></span> production.</li>
  <li><span class="param">semActs</span> is the set of semantic actions matching the <span class="prod"><a class="grammarRef" href="#prod-semanticActions">semanticActions</a></span> production.</li>

</ul>
  </td></tr>
<tr valign="baseline">
<td><a id="prod-cardinality" name="prod-cardinality"></a>[<span class="prodNo">53</span>]   </td>
<td><code class="production prod">cardinality</code></td>
<td>   ::=   </td>
<td><code class="content">"*" | "+" | "?" | <span class="prod"><a class="grammarRef" href="#term-REPEAT_RANGE">REPEAT_RANGE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-senseFlags" name="prod-senseFlags"></a>[<span class="prodNo">40</span>]   </td>
<td><code class="production prod">senseFlags</code></td>
<td>   ::=   </td>
<td><code class="content">"!" "^"? | "^" "!"?</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Value sets identify ranges of RDF nodes by explicit inclusion or by range (indicated by "<code>~</code>").
      Ranges may include exclusions, which may also be ranges but must not in turn contain exclusions.
      A <a href="#dfn-valueSetValue" class="param">valueSetValue</a> may be an <a class="param" href="#dfn-objectValue">objectValue</a> or a <a class="param" href="#dfn-Stem">Stem</a> or a <a class="param" href="#dfn-StemRange">StemRange</a>.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-valueSet" name="prod-valueSet"></a>[<span class="prodNo">41</span>]   </td>
<td><code class="production prod">valueSet</code></td>
<td>   ::=   </td>
<td><code class="content">"[" <span class="prod"><a class="grammarRef" href="#prod-valueSetValue">valueSetValue</a></span>* "]"</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-valueSetValue" name="prod-valueSetValue"></a>[<span class="prodNo">42</span>]   </td>
<td><code class="production prod">valueSetValue</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iriRange">iriRange</a></span> | <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span></code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-iriRange" name="prod-iriRange"></a>[<span class="prodNo">43</span>]   </td>
<td><code class="production prod">iriRange</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> ("~" <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>*)?<br/>
| "." <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>+</code></td>
</tr>
  <tr class="params"><td></td><td colspan="3">If <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> matches with no "<code>~</code>", iriRange returns <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span>.</td></tr>
  <tr class="params"><td></td><td colspan="3">If <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> and "<code>~</code>" match with no <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>, iriRange returns a <a href="#dfn-Stem" class="obj">Stem</a> object:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-Stem" class="obj">Stem</a></td><td>{</td><td><span class="param">stem</span>:<a class="trmref" href="#dfn-IRI">IRI</a> }</td></tr>
  <tr class="params"><td></td><td colspan="3">If <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> and "<code>~</code>" match and <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span> matches one or more times, iriRange returns a <a href="#dfn-StemRange" class="obj">StemRange</a> object with <span class="param">exclusions</span> equal to the set of results of <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>:</td></tr>
  <tr class="params"><td></td><td colspan="3">If "<code>.</code>" matches and <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span> matches one or more times, iriRange returns a <a href="#dfn-StemRange" class="obj">StemRange</a> object with <span class="param">exclusions</span> equal to the set of results of <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-StemRange" class="obj">StemRange</a></td><td>{</td><td><span class="param">stem</span>:(<a class="trmref" href="#dfn-IRI">IRI</a> | <a class="objref" href="#dfn-Wildcard">Wildcard</a>) <span class="param">exclusions</span>:[<a class="nobref" href="#dfn-valueSetValue">valueSetValue</a>]? }</td></tr>
  <tr class="params"><td></td><td colspan="3">If "<code>~</code>" matches with no <span class="prod"><a class="grammarRef" href="#prod-exclusion">exclusion</a></span>, iriRange returns a <a href="#dfn-Wildcard" class="obj">Wildcard</a> object:</td></tr>
  <tr class="obj"><td></td><td><a href="#dfn-Wildcard" class="obj">Wildcard</a></td><td>{</td><td><span class="comment">/* contains no properties */</span> }</td></tr>
<tr valign="baseline">
<td><a id="prod-exclusion" name="prod-exclusion"></a>[<span class="prodNo">44</span>]   </td>
<td><code class="production prod">exclusion</code></td>
<td>   ::=   </td>
<td><code class="content">"-" <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> "~"?</code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Triple expressions can include the <span class="prod"><a class="grammarRef" href="#prod-shapeExpression">shapeExpression</a></span> in a <span class="prod"><a class="grammarRef" href="#prod-shapeExprDecl">shapeExprDecl</a></span>.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-include" name="prod-include"></a>[<span class="prodNo">48</span>]   </td>
<td><code class="production prod">include</code></td>
<td>   ::=   </td>
<td><code class="content">"&amp;" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span></code></td>
</tr>
  <tr class="params"><td></td><td colspan="3">Per the <a href="#inclusion-constraint">inclusion constraint</a>, <span class="param">shapeLabel</span> property MUST appear in the schema's <span class="param">shapes</span> map and the corresponding triple expression MUST be a <span class="jobjref"><a href="#dfn-Shape">Shape</a></span> with a <span class="param">tripleExpr</span>.</td></tr>
<tr class="obj"><td></td><td><a href="#dfn-Inclusion" class="obj">Inclusion</a></td><td>{</td><td><span class="param">include</span>:<a class="nobref" href="#dfn-shapeLabel">shapeLabel</a> }</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Triple expressions can include annotations in the form of a tuple of a <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span> and an <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> or <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span>.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-annotation" name="prod-annotation"></a>[<span class="prodNo">50</span>]   </td>
<td><code class="production prod">annotation</code></td>
<td>   ::=   </td>
<td><code class="content">"//" <span class="prod"><a class="grammarRef" href="#prod-predicate">predicate</a></span> (<span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#prod-literal">literal</a></span>)</code></td>
</tr>
  <tr class="obj"><td></td><td><a href="#dfn-Annotation" class="obj">Annotation</a></td><td>{</td><td><span class="param">predicate</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">object</span>:<a class="nobref" href="#dfn-objectValue">objectValue</a> }</td></tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      Triple expressions can include semantic actions consisting of an <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> and an optional code string.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-semanticActions" name="prod-semanticActions"></a>[<span class="prodNo">49</span>]   </td>
<td><code class="production prod">semanticActions</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-codeDecl">codeDecl</a></span>*</code></td>
</tr>
<tr valign="baseline">
<td><a id="prod-codeDecl" name="prod-codeDecl"></a>[<span class="prodNo">62</span>]   </td>
<td><code class="production prod">codeDecl</code></td>
<td>   ::=   </td>
<td><code class="content">"%" <span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> (<span class="prod"><a class="grammarRef" href="#term-CODE">CODE</a></span> | "%")</code></td>
</tr>
  <tr class="obj"><td></td><td><a href="#dfn-SemAct" class="obj">SemAct</a></td><td>{</td><td><span class="param">name</span>:<a class="trmref" href="#dfn-IRI">IRI</a> <span class="param">code</span>:<a class="trmref" href="#dfn-STRING">STRING</a>? }</td></tr>
</tbody>

<!-- 
<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-includeSet" name="prod-includeSet"></a>[<span class="prodNo">64</span>]   </td>
<td><code class="production prod">includeSet</code></td>
<td>   ::=   </td>
<td><code class="content">"&amp;" <span class="prod"><a class="grammarRef" href="#prod-shapeLabel">shapeLabel</a></span>+</code></td>
</tr>
</tbody>
-->

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <p>
      The remaining productions come from the specifications for SPARQL and Turtle.
    </p>
  </td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-literal" name="prod-literal"></a>[<span class="prodNo">45</span>]   </td>
<td><code class="production prod">literal</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-rdfLiteral">rdfLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-numericLiteral">numericLiteral</a></span> | <span class="prod"><a class="grammarRef" href="#prod-booleanLiteral">booleanLiteral</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-predicate" name="prod-predicate"></a>[<span class="prodNo">51</span>]   </td>
<td><code class="production prod">predicate</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#term-RDF_TYPE">RDF_TYPE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-datatype" name="prod-datatype"></a>[<span class="prodNo">52</span>]   </td>
<td><code class="production prod">datatype</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-shapeLabel" name="prod-shapeLabel"></a>[<span class="prodNo">54</span>]   </td>
<td><code class="production prod">shapeLabel</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-iri">iri</a></span> | <span class="prod"><a class="grammarRef" href="#prod-blankNode">blankNode</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-numericLiteral" name="prod-numericLiteral"></a>[<span class="prodNo">55</span>]   </td>
<td><code class="production prod">numericLiteral</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> | <span class="prod"><a class="grammarRef" href="#term-DECIMAL">DECIMAL</a></span> | <span class="prod"><a class="grammarRef" href="#term-DOUBLE">DOUBLE</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-rdfLiteral" name="prod-rdfLiteral"></a>[<span class="prodNo">56</span>]   </td>
<td><code class="production prod">rdfLiteral</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#prod-string">string</a></span> (<span class="prod"><a class="grammarRef" href="#term-LANGTAG">LANGTAG</a></span> | "^^" <span class="prod"><a class="grammarRef" href="#prod-datatype">datatype</a></span>)?</code></td>
</tr>
    <tr id="handle-RDFLiteral" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the first rule argument, <code>String</code>. If the <code>'^^' iri</code> rule matched, the datatype is <code>iri</code> and the literal has no language tag. If the <code>LANGTAG</code> rule matched, the datatype is <code>rdf:langString</code> and the language tag is <code>LANGTAG</code>. If neither matched, the datatype is <code>xsd:string</code> and the literal has no language tag.</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-booleanLiteral" name="prod-booleanLiteral"></a>[<span class="prodNo">57</span>]   </td>
<td><code class="production prod">booleanLiteral</code></td>
<td>   ::=   </td>
<td><code class="content">"true" | "false"</code></td>
</tr>
    <tr id="handle-BooleanLiteral" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the <code>true</code> or <code>false</code>, depending on which matched the input, and a datatype of <code>xsd:boolean</code>.</td></tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-string" name="prod-string"></a>[<span class="prodNo">58</span>]   </td>
<td><code class="production prod">string</code></td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL1">STRING_LITERAL1</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></span><br/>
| <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL2">STRING_LITERAL2</a></span> | <span class="prod"><a class="grammarRef" href="#term-STRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-iri" name="prod-iri"></a>[<span class="prodNo">59</span>]   </td>
<td><code class="production prod">iri</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-IRIREF">IRIREF</a></span> | <span class="prod"><a class="grammarRef" href="#prod-prefixedName">prefixedName</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-prefixedName" name="prod-prefixedName"></a>[<span class="prodNo">60</span>]   </td>
<td><code class="production prod">prefixedName</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PNAME_LN">PNAME_LN</a></span> | <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span></code></td>
</tr>
</tbody>

<tbody class="prod">
<tr valign="baseline">
<td><a id="prod-blankNode" name="prod-blankNode"></a>[<span class="prodNo">61</span>]   </td>
<td><code class="production prod">blankNode</code></td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-BLANK_NODE_LABEL">BLANK_NODE_LABEL</a></span></code></td>
</tr>
</tbody>

<tbody class="grammarParagraph">
  <tr><td rowspan="2" colspan="4">
    <h3><a id="terminals" name="terminals">Terminals</a></h3>
    <p>
      Terminals return:
    </p>
    <ul>
      <li>the RDF abstract types <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri" class="math">IRI</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">lexical form</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">literal</a>, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-language-tag">language tag</a>.</li>
      <li>a string of unicode codepoints for <a href="#term-CODE">CODE</a>.</li>
      <li>a <code>repeat range</code> for <a href="#term-REPEAT_RANGE">REPEAT_RANGE</a>. A <code>repeat range</code> is a tuple of non-negative integers or a non-negative integer and a token for <code>Unbounded</code>.</li>
    </ul>
  </td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-CODE" name="term-CODE"></a>[<span class="prodNo">65</span>]   </td>
<td>&lt;<code class="production term">CODE</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"{" ([^%\\] | "\\" [%\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "%" "}"</code></td>
</tr>
    <tr id="handle-IRIREF" class="params"><td></td><td>returns: a string of unicode codepoints</td><td></td><td>The characters between "%" and "%}" are taken, with the <a href="http://www.w3.org/TR/2014/REC-turtle-20140225/#numeric">numeric escape sequences</a> unescaped, to form the unicode string of the IRI.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-REPEAT_RANGE" name="term-REPEAT_RANGE"></a>[<span class="prodNo">66</span>]   </td>
<td>&lt;<code class="production term">REPEAT_RANGE</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"{" <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> ( "," (<span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> | "*")? )? "}"</code></td>
</tr>
    <tr id="handle-IRIREF" class="params"><td></td><td>returns: repeat range</td><td></td><td>The base-10 numeric values of <span class="prod"><a class="grammarRef" href="#term-INTEGER">INTEGER</a></span> are taken or a non-negative integer and an <code>Unbounded</code> token if "<code>*</code>" was matched.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-RDF_TYPE" name="term-RDF_TYPE"></a>[<span class="prodNo">67</span>]   </td>
<td>&lt;<code class="production term">RDF_TYPE</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"a"</code></td>
</tr>
    <tr id="handle-PNAME_NS2" class="params"><td></td><td> returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI </a></td><td></td><td>The <code>iri</code> <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code> is returned.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-IRIREF" name="term-IRIREF"></a>[<span class="prodNo">68</span>]   </td>
<td>&lt;<code class="production term">IRIREF</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"&lt;" ([^#0000- &lt;&gt;\"{}|^`\\] | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "&gt;"</code></td>
</tr>
    <tr id="handle-IRIREF" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri" class="math">IRI</a></td><td></td><td>The characters between "&lt;" and "&gt;" are taken, with the <a href="http://www.w3.org/TR/2014/REC-turtle-20140225/#numeric">numeric escape sequences</a> unescaped, to form the unicode string of the IRI. Relative IRI resolution is performed per Turtle <a class="sectionRef" href="http://www.w3.org/TR/2014/REC-turtle-20140225/#sec-iri-references">Section 6.3</a>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PNAME_NS" name="term-PNAME_NS"></a>[<span class="prodNo">69</span>]   </td>
<td>&lt;<code class="production term">PNAME_NS</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></span>? ":"</code></td>
</tr>
    <tr id="handle-PNAME_NS" class="params"><td></td><td>returns: <a href="#dfn-Schema">                                 PREFIX      </a></td><td></td><td>When used in a <a href="#prod-prefixDecl">prefixDecl</a> production, the <code>prefix</code> is a potentially empty unicode string matching the first argument of the rule and serves as a key into the <a href="#dfn-Schema">prefixes map</a>.</td></tr>
    <tr id="handle-PNAME_NS2" class="params"><td></td><td> returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI </a></td><td></td><td>When used elsewhere, the <code>iri</code> is the value in the <a href="#dfn-Schema">prefixes map</a> corresponding to the first argument of the rule.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PNAME_LN" name="term-PNAME_LN"></a>[<span class="prodNo">70</span>]   </td>
<td>&lt;<code class="production term">PNAME_LN</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL">PN_LOCAL</a></span></code></td>
</tr>
    <tr id="handle-PNAME_LN" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI         </a></td><td></td><td>A potentially empty <a href="#dfn-Schema">prefix</a> is identified by the first token, <code>PNAME_NS</code>. The <a href="#dfn-Schema">prefixes map</a> <em class="rfc2119"><em class="rfc2119" title="MUST">MUST</em></em> have a corresponding <code>namespace</code>. The unicode string of the IRI is formed by unescaping the <a href="#reserved">reserved characters</a> in the second argument, <code>PN_LOCAL</code>, and concatenating this onto the <code>namespace</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-ATPNAME_NS" name="term-ATPNAME_NS"></a>[<span class="prodNo">71</span>]   </td>
<td>&lt;<code class="production term">ATPNAME_NS</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@" <span class="prod"><a class="grammarRef" href="#term-PN_PREFIX">PN_PREFIX</a></span>? ":"</code></td>
</tr>
    <tr id="handle-PNAME_NS2" class="params"><td></td><td> returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI </a></td><td></td><td>The <code>iri</code> is the value in the <a href="#dfn-Schema">prefixes map</a> corresponding to the second token of the rule.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-ATPNAME_LN" name="term-ATPNAME_LN"></a>[<span class="prodNo">72</span>]   </td>
<td>&lt;<code class="production term">ATPNAME_LN</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@" <span class="prod"><a class="grammarRef" href="#term-PNAME_NS">PNAME_NS</a></span> <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL">PN_LOCAL</a></span></code></td>
</tr>
    <tr id="handle-PNAME_LN" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-iri">      IRI         </a></td><td></td><td>A potentially empty <a href="#dfn-Schema">prefix</a> is identified by the second token, <code>PNAME_NS</code>. The <a href="#dfn-Schema">prefixes map</a> <em class="rfc2119"><em class="rfc2119" title="MUST">MUST</em></em> have a corresponding <code>namespace</code>. The unicode string of the IRI is formed by unescaping the <a href="#reserved">reserved characters</a> in the third token, <code>PN_LOCAL</code>, and concatenating this onto the <code>namespace</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-BLANK_NODE_LABEL" name="term-BLANK_NODE_LABEL"></a>[<span class="prodNo">73</span>]   </td>
<td>&lt;<code class="production term">BLANK_NODE_LABEL</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"_:" (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | [0-9]) ((<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ".")* <span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span>)?</code></td>
</tr>
    <tr id="handle-LANGTAG" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#blank-node">BNode</a></td><td></td><td>The characters following the "<code>_:</code>" form a blank node label. This corresponds to any BNode in the input dataset that had the same label.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-LANGTAG" name="term-LANGTAG"></a>[<span class="prodNo">74</span>]   </td>
<td>&lt;<code class="production term">LANGTAG</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"@" ([a-zA-Z])+ ("-" ([a-zA-Z0-9])+)*</code></td>
</tr>
    <tr id="handle-LANGTAG" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-language-tag">language tag</a></td><td></td><td>The characters following the <code>@</code> form the unicode string of the language tag.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-INTEGER" name="term-INTEGER"></a>[<span class="prodNo">75</span>]   </td>
<td>&lt;<code class="production term">INTEGER</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[+-]? [0-9]+</code></td>
</tr>
    <tr id="handle-INTEGER" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the input string, and a datatype of <code>xsd:integer</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-DECIMAL" name="term-DECIMAL"></a>[<span class="prodNo">76</span>]   </td>
<td>&lt;<code class="production term">DECIMAL</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[+-]? [0-9]* "." [0-9]+</code></td>
</tr>
    <tr id="handle-DOUBLE" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the input string, and a datatype of <code>xsd:double</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-DOUBLE" name="term-DOUBLE"></a>[<span class="prodNo">77</span>]   </td>
<td>&lt;<code class="production term">DOUBLE</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[+-]? ([0-9]+ "." [0-9]* <span class="prod"><a class="grammarRef" href="#term-EXPONENT">EXPONENT</a></span> | "."? [0-9]+ <span class="prod"><a class="grammarRef" href="#term-EXPONENT">EXPONENT</a></span>)</code></td>
</tr>
    <tr id="handle-DOUBLE" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-literal">            literal     </a></td><td></td><td>The literal has a lexical form of the input string, and a datatype of <code>xsd:double</code>.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-EXPONENT" name="term-EXPONENT"></a>[<span class="prodNo">78</span>]   </td>
<td>&lt;<code class="production term">EXPONENT</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[eE] [+-]? [0-9]+</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-STRING_LITERAL1" name="term-STRING_LITERAL1"></a>[<span class="prodNo">79</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL1</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"'" ([^'\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* "'"</code></td>
</tr>
    <tr id="handle-STRING_LITERAL1" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost "'"s   are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-STRING_LITERAL2" name="term-STRING_LITERAL2"></a>[<span class="prodNo">80</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL2</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'"' ([^\"\\\n\r] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>)* '"'</code></td>
</tr>
    <tr id="handle-STRING_LITERAL2" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost '"'s   are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-STRING_LITERAL_LONG1" name="term-STRING_LITERAL_LONG1"></a>[<span class="prodNo">81</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL_LONG1</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"'''" ( ("'" | "''")? ([^\\'\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* "'''"</code></td>
</tr>
    <tr id="handle-STRING_LITERAL_LONG1" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost "'''"s are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-STRING_LITERAL_LONG2" name="term-STRING_LITERAL_LONG2"></a>[<span class="prodNo">83</span>]   </td>
<td>&lt;<code class="production term">STRING_LITERAL_LONG2</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">'"""' ( ('"' | '""')? ([^\"\\] | <span class="prod"><a class="grammarRef" href="#term-ECHAR">ECHAR</a></span> | <span class="prod"><a class="grammarRef" href="#term-UCHAR">UCHAR</a></span>) )* '"""'</code></td>
</tr>
    <tr id="handle-STRING_LITERAL_LONG2" class="params"><td></td><td>returns: <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#dfn-lexical-form">                         lexical form</a></td><td></td><td>The characters between the outermost '"""'s are taken, with <a href="#numeric">numeric</a> and <a href="#string">string</a> escape sequences unescaped, to form the unicode string of a lexical form.</td></tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-UCHAR" name="term-UCHAR"></a>[<span class="prodNo">85</span>]   </td>
<td>&lt;<code class="production term">UCHAR</code>&gt;</td>
<td>   ::=   </td>
<td>   <code class="content">"\\u" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span><br/>
| "\\U" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-ECHAR" name="term-ECHAR"></a>[<span class="prodNo">86</span>]   </td>
<td>&lt;<code class="production term">ECHAR</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"\\" [tbnrf\\\"\\']</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PN_CHARS_BASE" name="term-PN_CHARS_BASE"></a>[<span class="prodNo">89</span>]   </td>
<td>&lt;<code class="production term">PN_CHARS_BASE</code>&gt;</td>
<td>   ::=   </td>
<td>   <code class="content">[A-Z] | [a-z]<br/>
| [#00C0-#00D6] | [#00D8-#00F6] | [#00F8-#02FF]<br/>
| [#0370-#037D] | [#037F-#1FFF]<br/>
| [#200C-#200D] | [#2070-#218F] | [#2C00-#2FEF]<br/>
| [#3001-#D7FF] | [#F900-#FDCF] | [#FDF0-#FFFD]<br/>
| [#10000-#EFFFF]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PN_CHARS_U" name="term-PN_CHARS_U"></a>[<span class="prodNo">90</span>]   </td>
<td>&lt;<code class="production term">PN_CHARS_U</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_BASE">PN_CHARS_BASE</a></span> | "_"</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PN_CHARS" name="term-PN_CHARS"></a>[<span class="prodNo">91</span>]   </td>
<td>&lt;<code class="production term">PN_CHARS</code>&gt;</td>
<td>   ::=   </td>
<td>   <code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | "-" | [0-9]<br/>
| [#00B7] | [#0300-#036F] | [#203F-#2040]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PN_PREFIX" name="term-PN_PREFIX"></a>[<span class="prodNo">92</span>]   </td>
<td>&lt;<code class="production term">PN_PREFIX</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PN_CHARS_BASE">PN_CHARS_BASE</a></span> ( (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ".")* <span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> )?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PN_LOCAL" name="term-PN_LOCAL"></a>[<span class="prodNo">93</span>]   </td>
<td>&lt;<code class="production term">PN_LOCAL</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">(<span class="prod"><a class="grammarRef" href="#term-PN_CHARS_U">PN_CHARS_U</a></span> | ":" | [0-9] | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>) ( (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | "." | ":" | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>)* (<span class="prod"><a class="grammarRef" href="#term-PN_CHARS">PN_CHARS</a></span> | ":" | <span class="prod"><a class="grammarRef" href="#term-PLX">PLX</a></span>) )?</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PLX" name="term-PLX"></a>[<span class="prodNo">94</span>]   </td>
<td>&lt;<code class="production term">PLX</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content"><span class="prod"><a class="grammarRef" href="#term-PERCENT">PERCENT</a></span> | <span class="prod"><a class="grammarRef" href="#term-PN_LOCAL_ESC">PN_LOCAL_ESC</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PERCENT" name="term-PERCENT"></a>[<span class="prodNo">95</span>]   </td>
<td>&lt;<code class="production term">PERCENT</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"%" <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span> <span class="prod"><a class="grammarRef" href="#term-HEX">HEX</a></span></code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-HEX" name="term-HEX"></a>[<span class="prodNo">96</span>]   </td>
<td>&lt;<code class="production term">HEX</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">[0-9] | [A-F] | [a-f]</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PN_LOCAL_ESC" name="term-PN_LOCAL_ESC"></a>[<span class="prodNo">97</span>]   </td>
<td>&lt;<code class="production term">PN_LOCAL_ESC</code>&gt;</td>
<td>   ::=   </td>
<td><code class="content">"\\" ( "_" | "~" | "." | "-" | "!" | "$" | "&amp;" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=" | "/" | "?" | "#" | "@" | "%" )</code></td>
</tr>
</tbody>

<tbody class="term">
<tr valign="baseline">
<td><a id="term-PASSED_TOKENS" name="term-PASSED_TOKENS"></a>[<span class="prodNo">98</span>]   </td>
<td><code class="production directive">PASSED TOKENS</code></td>
<td>   ::=   </td>
<td>   <code class="content">[ \t\r\n]+<br/>
| "#" [^\r\n]*</code></td>
</tr>
</tbody>

</table>
      </div>

      <div class="Example">
	<div class="with-highlight">
	  <p>
	    Moving the mouse over the elements of the list below will highlight the corresponding elements in the triple expression.
	    <ul>
	      <li><span class="hl-tc lowlight1">triple constraint</span> (<as><a href="#dfn-TripleConstraint">TripleConstraint</a></as>)</li>
	      <li><span class="hl-someof lowlight2">some-of triple expression</span> (<as><a href="#dfn-SomeOfTripleExpr">SomeOfTripleExpr</a></as>)</li>
	      <li><span class="hl-eachof lowlight2">each-of triple expression</span> (<as><a href="#dfn-EachOfTripleExpr">EachOfTripleExpr</a></as>)</li>
	      <li><span class="hl-repet lowlight3">repeated triple expression</span> (<as><a href="#dfn-RepeatedTripleExpr">RepeatedTripleExpr</a></as>)</li>
	      <li><span class="hl-inverse-tc lowlight1">triple constraint with an inverse property</span></li>
	      <!-- li><span class="hl-tc-cofinite lowlight1">triple constraint with a non-singleton co-finite set of properties</span></li -->
	      <li><span class="hl-shref lowlight4">shape reference</span> (<as><a href="#dfn-ShapeRef">ShapeRef</a></as>)</li>
	    </ul>
	  </p>
<pre class="shex">
# triple expression of the shapes language

&lt;S1&gt; {

<span class="hl-eachof lowlight2">  <span class="hl-tc lowlight1">rdf:type <span class="hl-shref lowlight4">@&lt;SL_1&gt;</span></span> ;

  <span class="hl-tc lowlight1">foaf:name <span class="hl-shref lowlight4">@&lt;SL_2&gt;</span></span> ;

  <span class="hl-someof lowlight2">( <span class="hl-repet lowlight3"><span class="hl-tc lowlight1">foaf:mbox <span class="hl-shref lowlight4">@&lt;SL_3&gt;</span></span> {1,3}</span> | <span class="hl-tc lowlight1">foaf:adress <span class="hl-shref lowlight4">@&lt;SL_3&gt;</span></span> )</span> ;

  <span class="hl-tc hl-inverse-tc lowlight1">^ex:leader &lt;SL_4&gt;</span> ;
<!--
  <span class="hl-repet lowlight3"><span class="hl-tc hl-tc-cofinite lowlight1">C{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox, ^ex:leader} <span class="hl-shref lowlight4">@&lt;SL_all&gt;</span></span> *</span>
--></span>}
</pre>
	  <!-- p>
	    Where <span class="pre">C{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox} = (Prop ∪ InvProp) \ {rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox}</span>, that is, the complement of the set <span class="pre">{rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox}</span> within the set of all properties and inverse properties.
	  </p -->
	</div>
	<script type="text/javascript">
	  <!--
	      prepareHighlight(["hl-tc", "hl-tc-cofinite", "hl-inverse-tc"], "highlight1", "lowlight1");
	      prepareHighlight(["hl-someof", "hl-eachof"], "highlight2", "lowlight2");
	      prepareHighlight(["hl-repet"], "highlight3", "lowlight3");
	      prepareHighlight(["hl-shref"], "highlight4", "lowlight4");
	    -->
	</script>
      </div>
      
    <section id="compilation-example">
      <h3>Examples of Compilating ShExC into ShExJ</h3>
	
	<section id="compilation-example-closed-shape">
	  <h4>Closed shape expression</h4>
	  
	  <div class="Example">
	    <div class="with-highlight">
	      <p>
		Every <span class="hl-issueshape hl-usershape lowlight2">shape label</span> from the ShEx schema is used as <span class="hl-issueshape lowlight2">shape label</span> in the shapes schema, which definition is the compilation of the definition from the ShEx schema.
	      </p>
	      <p>
		Every <span class="hl-ve1 hl-ve3 lowlight1">shape expression</span> that appears in a triple constraint of the ShEx schema yields a <span class="hl-ve1  hl-ve2 hl-ve3 hl-ve4 hl-ve4bis">fresh shape label having the same definition</span> in the shapes schema.
		This does not apply to shape expressions that are references.
	      </p>
	      <p>
		The translation of a CLOSED <span class="hl-te lowlight3">triple expression</span> in the ShEx schema translates almost directly to a <span class="hl-te lowlight3">triple expression</span> in the shapes schema, exept that predicates are replaced with singleton sets, and <span class="hl-ve1 hl-ve3 lowlight1">value expressions</span> are replaced with the corresponding freshly introduced <span class="hl-ve1 hl-ve3 lowlight1">shape labels</span> 
	      </p>

<pre class="shex" style="float:left">
# ShEx schema

<span class="hl-issueshape lowlight2">&lt;IssueShape&gt;</span>
<div class="hl-te lowlight3">
CLOSED {                 
    ex:state      <span class="hl-ve1 lowlight1">[ex:unassigned ex:assigned]</span> ; 
    ex:reportedBy @&lt;UserShape&gt; ;   
    ex:reportedOn <span class="hl-ve3 lowlight1">xsd:dateTime OR xsd:date</span> ;
    ex:related    @&lt;IssueShape&gt;* ;
    ^ex:related   @&lt;IssueShape&gt;*
}</div>
<span class="hl-usershape lowlight2">&lt;UserShape&gt;</span> {
    PATTERN "http://example.org/User#.*"
}
</pre>
<pre class="shex" style="float:left">
# shapes schema

<span class="hl-issueshape lowlight2">&lt;IssueShape&gt; </span>:= 
<div class="hl-te lowlight3">{
    {ex:state}      <span class="hl-ve1 lowlight1">&lt;SL_1&gt;</span> ;
    {ex:reportedBy} &lt;UserShape&gt;
    {ex:reportedOn} <span class="hl-ve3 lowlight1">&lt;SL_3&gt;</span> ;
    {ex:related}    &lt;IssueShape&gt;*  ;
    {^ex:related}   &lt;IssueShape&gt;*
}
</div>

<span class="hl-usershape lowlight2">&lt;UserShape&gt;</span> {
    Set(PATTERN "http://example.org/User#.*")
}


<span class="hl-ve1 lowlight1">&lt;SL_1&gt;  := {ex:unassigned, ex:assigned}</span>
<span class="hl-ve3 lowlight1">&lt;SL_3&gt;  := xsd:dateTime OR xsd:date</span>
</pre>

	    </div>
	    <script type="text/javascript">
	      <!--
		  prepareHighlight(["hl-ve1", "hl-ve3" ], "highlight1", "lowlight1");
		  prepareHighlight(["hl-issueshape", "hl-usershape"], "highlight2", "lowlight2");
		  prepareHighlight(["hl-te"], "highlight3", "lowlight3");
		-->
	    </script>
	    <div style="clear:both;"> </div>
	  </div>	  
	</section>

      <section id="translate-example-closed-with-extra">
	<h4>Closed shape expression with EXTRA modifier</h4>

	<div class="Example">
	  <div class="with-highlight">
	    <p>
	      As in the previous example, the value expressions of the ShEx schema yield shape labels with the same definition. Here, the resulting fresh shape labels are <span class="pre">&lt;SL_5&gt;, &lt;SL_6&gt;, &lt;SL_7&gt;, &lt;SL_8&gt;</span>.
	    </p>
	    <p>
	      The <span class="hl-shapexpr lowlight3">triple expression</span> from the ShEx schema is translated into a <span class="hl-shapexpr lowlight3">triple expression</span> in the shapes schema.
	      <span class="hl-samete lowlight1">One part of that triple expression</span> is a direct translation of <span class="hl-samete lowlight1">the triple expression from the ShEx schema</span>.
	    </p>
	    <p>
	      The <span class="hl-extra lowlight1">EXTRA modifier</span> results in <span class="hl-extra lowlight1">additional triple constraints</span> in the shapes schema. 
	      There is one such triple constraint with * cardinality for every extra property. 
	      For every extra property, the <span class="hl-extra-ve1 hl-extra-ve2 lowlight2">value expression is the negation of the value expressions that occur with the same property</span>.
	    </p>

<pre class="shex" style="float:left">
# ShEx schema
	      
	      
	      






&lt;UserShape&gt;
<div class="hl-shapexpr lowlight3">CLOSED 
<span class="hl-extra">EXTRA rdf:type foaf:mbox</span> {
<div class="hl-samete lowlight4">
    rdf:type <span class="hl-extra-ve1 lowlight2">[foaf:Person]</span> ;
    rdf:type <span class="hl-extra-ve1 lowlight2">[ex:User]</span> ;
    (                                   
       foaf:name xsd:string 
     |                                  
       foaf:givenName xsd:string+ ;      
       foaf:familyName xsd:string
    );
    foaf:mbox <span class="hl-extra-ve2 lowlight2">IRI</span>
</div>
}
</div>
</pre>


<pre class="shex" style="float:left">
# shapes schema

&lt;SL_5&gt; := {foaf:Person}
&lt;SL_6&gt; := {ex:User}
&lt;SL_7&gt; := xsd:string
&lt;SL_8&gt; := IRI

&lt;SL_UserShape_Extra_rdftype&gt; := <span class="hl-extra-ve1 lowlight2">NOT{foaf:Person} AND NOT{ex:User}</span>
&lt;SL_UserShape_Extra_foafmxbox&gt; := <span class="hl-extra-ve2 lowlight2">NOT IRI</span>


&lt;UserShape&gt; := 
<div class="hl-shapexpr lowlight3">{
<div class="hl-samete lowlight4">    {rdf:type}  &lt;SL_5&gt; ;
    {rdf:type}  &lt;SL_6&gt; ;
    (
        {foaf:name}       &lt;SL_7&gt;
    |
        {foaf:givenName}  &lt;SL_7&gt;+ ;
        {foaf:familyName} &lt;SL_7&gt;
    );
    {foaf:mbox} &lt;SL_8&gt; ;
</div>
<div class="hl-extra lowlight1">    {rdf:type}  <span class="hl-extra-ve1 lowlight2">&lt;SL_UserShape_Extra_rdftype&gt;</span> * ;
    {foaf:mbox} <span class="hl-extra-ve2 lowlight2">&lt;SL_UserShape_Extra_foafmbox&gt;</span> * ;
</div>
}
</div>
</pre>
<div style="clear:both;"> </div>

	  </div>  
	</div>
	<script type="text/javascript">
	  <!--
	      prepareHighlight(["hl-extra"], "highlight1", "lowlight1");
	      prepareHighlight(["hl-extra-ve1", "hl-extra-ve2"], "highlight2", "lowlight2");
	      prepareHighlight(["hl-shapexpr"], "highlight3", "lowlight3");
	      prepareHighlight(["hl-samete"], "highlight4", "lowlight4");
	    -->
	</script>
      </section>

      <section id="compilation-example-non-closed-shape">
	<h4>Non closed shape expression</h4>
	<div class="Example">
	  <div class="with-highlight">
	    <p>
	      As for the case with EXTRA properties, the <span class="hl-shapexpr lowlight3">shape expression</span> from the ShEx schema is tranlated into a <span class="hl-shapexpr lowlight3">triple expression</span> with an <span class="hl-open-tc lowlight4">additional triple constraint with * cardinality</span>.
	      The <span class="hl-propset lowlight2">set of properties</span> of the latter is the set of <span class="hl-propset lowlight2">all properties that do not appear in the shape expression</span>. 
	      The <span class="hl-ve lowlight1">value expression</span> accepts all values.
	    </p>
	    
	    
<pre class="shex" style="float:left">
# ShEx schema





&lt;SomeShape&gt; 
<div class="hl-shapexpr lowlight3">{
    ex:p xsd:int* ;
    ( ex:q xsd:int | ex:r IRI )? 
}
</div>
</pre>
<pre class="shex" style="float:left">
# shapes schema

&lt;SL_9&gt;  := xsd:int
&lt;SL_10&gt; := IRI

<span class="hl-ve lowlight1">&lt;SL_all_values&gt;  := IRI ∪ RDFLiteral ∪ {blank}</span>

&lt;SomeShape&gt; := 
<div class="hl-shapexpr lowlight3">{
    {ex:p}  &lt;SL_9&gt;* ;
    ( {ex:q}  &lt;SL_9&gt; | {ex:r} &lt;SL_10&gt; )? ;

<span class="hl-open-tc lowlight4">    <span class="hl-propset lowlight2">PropSet</span>  <span class="hl-ve lowlight1">&lt;SL_all_values&gt;</span>*    </span>
}
</div>

# with <span class="hl-propset lowlight2">PropSet = (Prop ∪ InvProp) \ {ex:p, ex:q, ex:r}</span>
</pre>
<div style="clear:both;"> </div>

	  </div>
	  <script type="text/javascript">
	    <!--
		prepareHighlight(["hl-ve"], "highlight1", "lowlight1");
		prepareHighlight(["hl-propset"], "highlight2", "lowlight2");
		prepareHighlight(["hl-shapexpr"], "highlight3", "lowlight3");
		prepareHighlight(["hl-open-tc"], "highlight4", "lowlight4");
	      -->
	  </script>
	</div>
      </section>

      <section id="compilation-example-conjunctive-shape">
	<h4>Complex shape definition</h4>

	<div class="Example">
	  <div class="with-highlight">
	    <p>
	      The shape label <span class="pre">&lt;EmployeeShape&gt;</span> is defined as a conjunction of <span class="hl-nc lowlight2">node constrints</span> and <span class="hl-te1 hl-te2 lowlight3">triple expressions</span>.
	      In the shapes schema, this yields a <span class="hl-conj lowlight4"><a href="#dfn-ShapeAnd">ShapeAnd</a> shape expression</span> with one conjunct per conjunct in the ShEx schema.
	    </p>
	    
<pre class="shex" style="float:left">
# ShEx schema

&lt;EmployeeShape&gt;
<span class="hl-nc lowlight2">PATTERN "^http:/example.org/.*"</span>

<div class="hl-te1 lowlight3">CLOSED {        
    foaf:phone IRI*;          
    foaf:mbox IRI             
}
</div>
AND 

<div class="hl-te2 lowlight3">CLOSED {
    ( foaf:phone PATTERN "^tel:\\+33" ; 
      foaf:mbox  PATTERN "\\.fr$" )?   ;
    ( foaf:phone PATTERN "^tel:\\+44" ; 
      foaf:mbox  PATTERN "\\.uk$")?
}
</div>
</pre>

<pre class="shex" style="float:left">
# shapes schema

&lt;SL_11&gt; := Set(PATTERN "^tel:\\+33")
&lt;SL_12&gt; := Set(PATTERN "\\.fr$")
&lt;SL_13&gt; := Set(PATTERN "^tel:\\+44")
&lt;SL_14&gt; := Set(PATTERN "\\.uk$")
&lt;SL_15&gt; := IRI

&lt;EmployeeShape&gt; := {<div class="hl-conj lowlight4">
    <span class="hl-nc lowlight2">Set(PATTERN "^http:/example.org/.*")</span>

    AND 
<div class="hl-te1 lowlight3">
    {foaf:phone} &lt;SL_15&gt;* ;
    {foaf:mbox}  &lt;SL_15&gt;
</div>
    AND 
<div class="hl-te2 lowlight3">
    ( {foaf:phone} &lt;SL_11&gt; ;
      {foaf:mbox}  &lt;SL_12&gt; )? ;
    ( {foaf:phone} &lt;SL_13&gt; ;
      {foaf:mbox}  &lt;SL_14&gt; )?
</div>
}
</div>
</pre>
<div style="clear:both;"> </div>

	  </div>
	  <script type="text/javascript">
	    <!--
		prepareHighlight([], "highlight1", "lowlight1");
		prepareHighlight(["hl-nc"], "highlight2", "lowlight2");
		prepareHighlight(["hl-te1", "hl-te2"], "highlight3", "lowlight3");
		prepareHighlight(["hl-conj"], "highlight4", "lowlight4");
	      -->
	  </script>
	</div>
      </section>

      <section id="compilation-example-negated-triple-constraint">
	<h4>Negated triple expression</h4>
	<div class="Example">
	  <div class="with-highlight">

	    <p>
	      The <span class="hl-negte lowlight4">negated triple constraint</span> is treated as if <span class="hl-prop lowlight2">its property</span> was an <span class="hl-prop lowlight2">extra property</span>.
	      The corresponding <span class="hl-negte lowlight4">triple constraint in the translation</span> has a <span class="hl-zerocard lowlight3">{0;0} cardinality</span>.
	    </p>

<pre class="shex" style="float:left">
# ShEx schema

&lt;SomeShape&gt; 
CLOSED {
    ex:p xsd:int* ;
    (<span class="hl-negte lowlight4"> ! <span class="hl-prop lowlight2">ex:q</span> xsd:int </span> 
      | ex:r IRI )? 
}
</pre>
<pre class="shex" style="float:left">
# shapes schema

&lt;SL_9&gt;  := xsd:int
&lt;SL_10&gt; := IRI
&lt;SL_Extra&gt; := NOT xsd:int

&lt;SomeShape&gt; := { 
    {ex:p}  &lt;SL_9&gt;* ;
    (<span class="hl-negte lowlight4"> {ex:q}  &lt;SL_9&gt;<span class="hl-zerocard lowlight3">{0;0}</span> </span>
      | {ex:r} &lt;SL_10&gt; )? ;

    <span class="hl-prop lowlight2">{ex:q}</span>  &lt;SL_Extra&gt;*
}

</pre>
<div style="clear:both;"></div>

	  </div>
	  <script type="text/javascript">
	    <!--
		prepareHighlight([], "highlight1", "lowlight1");
		prepareHighlight(["hl-prop"], "highlight2", "lowlight2");
		prepareHighlight(["hl-zerocard"], "highlight3", "lowlight3");
		prepareHighlight(["hl-negte"], "highlight4", "lowlight4");
	      -->
	  </script>
	</div>
      </section>
    </section>
    </section>

    <script>
      $("m").wrapInner("<span class='math'/>").children(0).unwrap();
      $("as").wrapInner("<span class='as'/>").children(0).unwrap();
      $("parm").wrapInner("<span class='param'/>").children(0).unwrap();
    </script>
    <script>
    </script>

  </body>
</html>
