<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>Semantics of Shape Expressions Schemas</title>
    <link rel="stylesheet" href="css/wgio.min.css"/>

    <script src='../primer/respec-w3c-common.js' async class='remove'></script>
    <script src="http://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>
    <script class='remove'>
      var respecConfig = {
      specStatus: "base",
      shortName:  "shex-primer",
      // edDraftURI: "http://w3c.github.io/data-shapes/primer/",
      editors: [
      {   name:       "Iovka Boneva",
      url:        "http://cristal.univ-lille.fr/~boneva/",
      company:    "University of Lille",
      companyURL: "http://univ-lille1.fr/" }
      ],
      // wg:           "Shape Expressions ",
      // wgURI:        "https://shex.io/",
      // wgPublicList: "public-shex-dev",
      // wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
      };
    </script>
    <style>
      .Definition{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F0F0;
      }
      .Example{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #FFF0F0;
      }

      .pre{
      font-family: monospace;
      
      }
      
      .abstrsynt{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F8F8;
      line-height: 1.5;
      }
     

      .concrsynt{
      font-size: 80%;
      }

      .emph{
      font-style: italic;
      }

      .textbf{
      font-weight: bold;
      }
      .math{
      font-style: normal;
      font-family: sans-serif;
      color: #006666;
      }

      .as{
      font-style: normal;
      font-family: sans-serif;
      color: #000066
      }

      .mathbf{
      font-weight: bold;
      font-family: sans-serif;
      }

      
      tr th { text-align: center; }
      .todo {
      color: red;
      }
      pre {
      tab-size: 4;
      }
      th {
      text-align: left;
      }
      .comment {
      /* font-lock-comment-face */
      color: #b22222;
      }
      .shh { color: #bbb; margin:0; }
      .constant {
      /* font-lock-constant-face */
      color: #008b8b;
      }
      .function-name {
      /* font-lock-function-name-face */
      color: #0000ff;
      }
      .function-name:visited {
      /* font-lock-function-name-face */
      color: #0000ff;
      }
      .keyword {
      /* font-lock-keyword-face */
      color: #a020f0;
      }
      .string {
      /* font-lock-string-face */
      color: #8b2252;
      }
      .type {
      /* font-lock-type-face */
      color: #228b22;
      }
      .shape-name {
      /* font-lock-variable-name-face */
      color: #a0522d;
      }
      .shape-name:visited {
      /* font-lock-variable-name-face */
      color: #a0522d;
      }
      .constraint-name { color: #a08000; }
      .predicate {
      /* font-lock-variable-name-face */
      color: #522da0;
      }
      .value-constraint {
      /* font-lock-variable-name-face */
      color: #2d52a0;
      }
      .example {
      display: inline-block;
      }
      .example.wrapper {
      background-color: #fff;
      }
      .example.wrapper pre {
      background-color: #fcfaee;
      margin-left: 0;
      line-height: 1.2;
      display: table;
      }
      .example.wrapper .fail {
      background-color: #fceefa
      }
      pre.schema.shexc { background-color: #ECEBF7; border: thick solid #e4e3ec; }
      pre.schema.json { background-color: #ECEBF7; border: thick solid #DCDBE7; }
      pre.instance { border: thick solid #f8f6ea; }
      .verticalDivider {
      float: left;
      width: .5em;
      border:thin solid #fff; /* disappears without this */
      }
      
      .highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
      .highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
      .lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
      .highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
      .lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
      .lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
      
      .highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
      .lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
      .highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
      .lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }
      
      .new            { font-weight: bold; }
      .errorSite      { color: red; }
      
      
      .issue div p { margin-left: 1em; }
      pre.shh { display: table; }
      .compact p { margin: 0; }
      .compact li { margin-bottom: 1ex; }
      #respecDocument img { width: 72px; }
      a.ref { color: #c83500; font-family: monospace; }
      a.ref:visited { color: #a00550; font-family: monospace; }
      .example.wrapper pre+pre { margin-top: 0; }
      #closed-shapes-example-2 pre { margin-top: 0; }
    </style>
    <script src="jquery.min.js" type= "text/javascript"></script>
    <script type="text/javascript"> </script>
  </head>
  
  <body>
    <section id="abstract">
      <p>
	This document describes the formal semantics of Shape Expressions (ShEx) schemas.
	The semantics is defined on a slight generalization of ShEx schemas, called the shapes language.
	The generalization consists in:
	<ul>
	  <li>triple constraints use sets of predicates, instead of a single predicate;</li>
	  <li>value expressions are generalized to arbitrary Boolean combinations of constraints on the value of the focus node and constraints the neighbour triples of the focus node.</li>
	</ul>
	The generalization allows to have a simpler syntax, by seeing some of the ShEx constructs as syntactic abbreviations.
	This makes the description of the semantics shorter.
	After defining the shapes language and its semantics, we show how ShEx schemas translate to it.
      </p>
    </section>

    <section id="abstraction-rdf-graphs">
      <h2>RDF Graphs</h2>
      <p>
	Let <m>IRI</m> be the set of IRI, <m>Lit</m> be the set of literal values, and <m>Blank</m> be the set of blank nodes.
	Recall that an RDF graph is a set of triples in <m>(IRI &cup; Blank) &times; IRI &times; (IRI &cup; Blank &cup; Lit)</m>.
	For a triple <m>(s,p,o)</m>, <m>s</m> is called the subject, <m>p</m> is called the predicate, and <m>o</m> is called the object of the triple.
      </p>
      <p>
	For a graph <m>G</m>, we define the following sets:
	<ul>
	  <li>
	    <m>Nodes(G)</m> is the set nodes of <m>G</m> and is defined as the set of IRI or blank nodes or literal values that occupy a subject or object position in some triple of <m>G</m>
	  </li>
	  <li>
	    <m>Props(G)</m> is the set of properties of <m>G</m> and is defined as the set of IRI that occupy a predicate position in some triple of <m>G</m>
	  </li>
	  <li>
	    <m>InvProps(G)</m> is the set of inverse properties of <m>G</m> and is defined as the properties of <m>G</m> decorated by a hat  <m>^</m>. That is, if <m>prop</m> is a property, then <m>^prop</m> is an inverse property.
	  </li>
	  <li>
	    for a triple <m>(node', prop, node)</m> in <m>G</m>, its inverse triple is the triple <m>(node, ^prop, node')</m>. 
	    Note that inverse triples are note elements of the graph. 
	    [FOOTNOTE: inverse triples are going to be used for defining the semantics for inverse triple constraints]
	  </li>
	  <li>
	    <m>neigh(G,n)</m> is the neighbourhood of the node <m>n</m> in the graph <m>G</m>, and is defined as the set of all triples whose subject is the node <m>n</m> and all inverses of the triples whose object is <m>n</m>.
	    More formally, <m>neigh(G,n) = {(node, prop, node') | (node, prop, node') &in; G} &cup; {(node, ^prop, node') | (node', prop, node) &in; G}</m>.
	  </li>
	</ul>
      </p>

      <p>
	Additionally, we define 
	<ul>
	  <li>
	    <m>Prop</m> as a synonym of the set <m>IRI</m>, that we are going to use specifically to designate IRI that appear as predicates in the triples in graphs
	  </li>
	  <li>
	    <m>InvProp</m> as the set inverse properties, that are IRIs decorated by the hat.
	  </li>
	</ul>
      </p>

      <div class="Example">
	<p>
	  Consider the RDF graph <m>G</m> given by:
	</p>

	<pre>
PREFIX ex: http://ex.example/#
PREFIX foaf: http://xmlns.com/foaf/
PREFIX xsd: http://www.w3.org/2001/XMLSchema#

inst:Issue1 
    ex:state      ex:unassigned ;
    ex:reportedBy inst:User2 .

inst:User2
    foaf:name     "Bob Smith" ;
    foaf:mbox     &lt;mailto:bob@example.org&gt; .
         </pre>
	<p>
	  The set <m>Nodes(G)</m> of the nodes of <m>G</m> is
<pre>
    { inst:Issue1, ex:unassigned, inst:User2, "Bob Smith", &lt;mailto:bob@example.org&gt; }
</pre>
	</p>
	<p>
	  The set <m>Props(G)</m> of the properties of <m>G</m> is
<pre>
    { ex:state, ex:reportedBy, foaf:name, foaf:mbox }
</pre>
	</p>

	<p>
	  The set <m>InvProps(G)</m> of inverse properties of <m>G</m> is
<pre>
    { ^ex:state, ^ex:reportedBy, ^foaf:name, ^foaf:mbox }
</pre>
	</p>

	<p>
	  The set <m>neigh(G, <span class="pre">inst:User2</span>)</m>, neighbourhood of the node <span class="pre">inst:User2</span> is the set composed of the following triples and inverse triples:
<pre>
    inst:User2  foaf:name  "Bob Smith" .
    inst:User2  foaf:mbox  &lt;mailto:bob@example.org&gt; .
    inst:User2  ^ex:reportedBy  inst:Issue1 .
</pre>
	</p>
      </div>
    </section>

    <section id="shex-abstrsynt">
      <h2>Abstract Syntax of ShEx Schemas</h2>

      <p>
	The abstract syntax of ShEx schemas is given by the following rules.
      </p>

      <div class="abstrsynt">
	<as>ShapeExpressionsSchema ::= (ShapeLabel ShapeDefinition)+</as><br/>
	<as>ShapeLabel ::= </as> an identifier <br/>
	<as>ShapeDefinition ::= NodeConstraint* ShapeExpressions?</as><br/>
	<as>ShapeExpressions ::= ShapeExpression ('AND' ShapeExpression)*</as><br/>
	<as>NodeConstraint ::= </as> a subset of <as>IRI &cup; Lit &cup; {blank}</as><br/>
	<br/>
	<as>ShapeExpression ::= 'CLOSED'? '^CLOSED'? ('EXTRA' ExtraPropSet)? TripleExpression</as><br/>
	<as>ExtraPropSet ::= </as> a set of properties and inverse properties<br/>
	<as>TripleExpression ::= EmptyTripleExpr</as><br/>
	<as> | TripleConstraint</as><br/>
	<as> | SomeOfTripleExpr</as><br/>
	<as> | EachOfTripleExpr</as><br/>
	<as> | RepeatedTripleExpr</as><br/>
	<br/>
	<as>EmptyTripleExpr ::= 'EMPTY'</as><br/>
	<as>TripleConstraint ::= (Property | InvProperty) ValueExpression</as><br/>
	<as>Property ::=</as> an IRI<br/>
	<as>InvProperty ::= '^'Property</as><br/>
	<br/>
	<as>SomeOfTripleExpr ::= TripleExpr '|' TripleExpr</as><br/>
	<as>EachOfTripleExpr ::= TripleExpr ';' TripleExpr</as><br/>
	<br/>
	<as>RepeatedTipleExpr ::= TripleExpr '[' MinCard ';' MaxCard ']'</as><br/>
	<as>MinCard ::= </as>a natural number<br/>
	<as>MaxCard ::= </as>a natural number or '*'<br/>
	<br/>
	<as>ValueExpression ::= ValueConstraint</as><br/>
	<as> | ConjunctiveValueExpr</as><br/>
	<as> | DisjunctiveValueExpr</as><br/>
	<as>ValueConstraint ::= NodeConstraint*</as><br/>
	<as> | ShapeRef</as><br/>
	<as>ShapeRef ::= '@' ShapeLabel</as><br/>
	<as>ConjunctiveValueExpr ::= ValueExpression 'AND' ValueExpression</as><br/>
	<as>DisjunctiveValueExpr ::= ValueExpression 'OR' ValueExpression</as><br/>
      </div>
      
      <p>
	A shape expressions schema defines a set of shape labels, together with their definition.
      </p>
      
      <p>
	TODO: explanation of the constructs of a ShEx schema
      </p>

      <div class="Example">
	<p>
	  In this example we illustrate how concrete syntax of ShEx in Turtle format corresponds to the abstract syntax presented above.
	</p> 
	<p>
	  Here is a ShEx schema written in Turtle format.
	  The leading numbers are line numbers used for reference.
	</p>


<pre>

      RREFIX ex:   &lt;http://ex.example/#&gt;
      PREFIX foaf: &lt;http://xmlns.com/foaf/&gt;
      PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
      PREFIX rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

1     &lt;IssueShape&gt; CLOSED EXTRA rdf:type
2     {                           
3         rdf:type [ex:Issue];
4         ex:state [ex:unassigned ex:assigned]; 
5                                            
6         ex:reportedBy @&lt;UserShape&gt;;   
7         ex:reportedOn xsd:dateTime;         
8         (                                   
9           ex:reproducedBy @&lt;EmployeeShape&gt;;  
10          ex:reproducedOn xsd:dateTime OR xsd:date 
11        )?;
12        ^ex:related @&lt;IssueShape&gt;*            
13    }
14
15    &lt;UserShape&gt; PATTERN "^http:/example.org/.*" {                     
16        (                                   
17           foaf:name xsd:string             
18         |                                  
19           foaf:givenName xsd:string+;      
20           foaf:familyName xsd:string
21        );     
22        foaf:mbox IRI              
23    }
24
25    &lt;EmployeeShape&gt; {        
26        foaf:phone IRI*;          
27        foaf:mbox IRI             
28    } AND {
29        ( foaf:phone PATTERN "^tel:\\+33"; 
30          foaf:mbox PATTERN "\\.fr$" )?;
31        ( foaf:phone PATTERN "^tel:\\+44"; 
32          foaf:mbox PATTERN "\\.uk$")?
33    }
</pre>

	<p>
	  We first explain some elements of the concrete syntax. 
	  A triple expression is surrounded by curly braces { and }.
	  The square braces delimit sets of values.
	  Parentheses are used as usual for defining the structre of an expression.
	  We use abbreviations for some intervals of min and max cardinality, namely, '+' is the interval [1;*], '*' is the interval [0;*], and '?' is the interval [0;1].
	</p>

	<p>
	  Then, the schema here above defines three shape labels: <span class="pre">&lt;IssueShape&gt;, &lt;UserShape&gt;, &lt;EmployeeShape&gt</span>.
	</p>
	<p>
	  The shape expression that defines the shape label <span class="pre">&lt;IssueShape&gt;</span> starts on line 1 after the shape label, and ends with the curly bracket on line 13.
	  It has an empty list of node constraints, and a single shape definition.
	  The shape definition has two modifiers, <m>CLOSED</m>, and <m>EXTRA</m>. 
	  The parameter of the <m>EXTRA</m> modifier is a singleton set that contains the property <span class="pre">rdf:type</span>.
	</p>
	<p>
	  The triple expression in the shape definition is given between the curly braces on lines 2 and 13.
	  It is an each-of expression composed of six sub-expressions, separated by semicolons. 
	  The sub-expressions are as follows:
	  <ul>
	    <li>
	      Four triple constraints on lines 3, 4, 6, 7.
	    </li>
	    <li>
	      Two repeated triple expressions, one on lines 8--11 with cardinality ? = [0;1], another one on line 12 with cardinality * = [0;*].
	    </li>
	  </ul>
	</p>

	<p>
	  We explain the different forms of triple constraint that appear in the definition of <span class="pre">&lt;IssueShape&gt;</span>, by explaining their property or their value expression.
	</p>

<pre>
1     &lt;IssueShape&gt; CLOSED EXTRA rdf:type
2     {                           
3         rdf:type [ex:Issue];                            # the property is rdf:type, 
                                                          # the value expression is a node constraint 
                                                          #    that is a singleton set containing the IRI ex:Issue

4         ex:state [ex:unassigned ex:assigned];           # the property is ex:state
5                                                         # the value expression is a set with two IRI,
                                                          #    ex:unassigned and ex:assigned

6         ex:reportedBy @&lt;UserShape&gt;;                     # the value expression is a ShapeExprRef 

7         ex:reportedOn xsd:dateTime;                     # the value expression is a the set of literal values 
                                                          #    that have XSD type xsd:dateTime
8         (                                   
9           ex:reproducedBy @&lt;EmployeeShape&gt;;  
10          ex:reproducedOn xsd:dateTime OR xsd:date      # the value expression is DisjunctiveValueExpr,
                                                          #    whose sub-expressions are sets of literal values
11        )?;
12        ex:related @&lt;IssueShape&gt;*            
13    }
</pre>

	<p>
	  We now explain a few other elements of the syntax.
	</p>

<pre>
15    &lt;UserShape&gt; PATTERN "^http:/example.org/.*" {                     
         ...
23    }
</pre>	

	<p>
	  The shape expression that defines <span class="pre">&lt;UserShape&gt;</span> is composed of one node constraint <span class="pre">PATTERN "^http:/example.org/.*"</span> and one shape definition between the curly braces lines 15 to 23.
	  The node constraint <span class="pre">PATTERN "^http:/example.org/.*"</span> defines the set of IRI that satisfy a pattern given by a regular expression.
	</p>

<pre>
25    &lt;EmployeeShape&gt; {        
        ...
28    } AND {
        ...
33    }
</pre>

	<p>
	  The shape expression that defines <span class="pre">&lt;EmployeeShape&gt;</span> is composed of zero node constrainst, and two shape definitions, separated by an <span class="pre">AND</span>.
	</p>
      </div>
    </section>


    <section id="shapes-language">
      <h2>The Shapes Language</h2>
      <p>
	A shapes schema defines a set of named value constraints, and a set of named shapes.
	The names are used to refer to value constraints and shapes.
	The name of a value constraint is called value constraint label, and the name of a shape is called shape label.
      </p>

      <p>
	<span class="textbf">All non-terminal symbols in the abstract syntax of shapes schemas end with an underscore _.
	  This helps to avoid confusion between non-terminals of ShEx and shapes schemas. </span>
      </p>


      <h3>Shapes Schema</h3>
      <p>
	Formally, a shapes schema <m>Sch</m> is given by a triple <m>Sch = (SLabels, TELabels, def)</m> where 
	<ul>
	  <li>
	    <m>SLabels</m> is a set of shape labels
	  </li>
	  <li>
	    <m>TELabels</m> is a set of triple expression labels, and
	  </li>
	  <li>
	    <m>def</m> is a definition function that with every shape label associates a value expression, and with every triple expression label associates a triple expression. 
	  </li>
	</ul>
      </p>

      <p>
	The structure of a shapes schema is captured by the following abstract syntax.
      </p>
      <div class="abstrsynt">
	<as>ShapesSchema_ ::= (ShapeLabel_ ValueExpression_)+ (TripleConstraintLabel_ TripleExpression_)*</as><br/>
<!-- 	<as>ValueConstraintDefinition_ ::= ValueConstraintLabel_ ValueExpression_</as><br/> -->
<!-- 	<as>ShapeDefinition_ ::= ShapeLabel_ TripleExpression_ -->
<!-- </m><br/> -->
      </div>


      <h3>Typing of a Graph by a Shapes Schema</h3>

      <p>
	A typing is a set of node-label associations of the form <m>(node,T)</m> where <m>node</m> is a node in a graph, and <m>T</m> is a triple expression label from a schema.
	A node-label association intuitively indicates that the node <m>node</m> satisfies the constraint given by the definition of the triple expression label <m>T</m>.
      </p>
      <p>
	Formally, let <m>Sch = (SLabels, TELabels, def)</m> be a shapes schema and <m>G</m> be a graph.
	A typing of <m>G</m> by <m>Sch</m> is a subset of <m>Nodes(G) &times; TELabels</m>.
      </p>


      <div class="Example">
	<p>
	  Consider a shapes schema <m>Sch =  (SLabels, TELabels, def)</m> with 
	  <m>TELabels = {<span class="pre">&lt;TE_Issue&gt;, &lt;TE_User&gt;, &lt;TE_Employee&gt;</span>}</m>.
	</p>
	<p>
	  An example of a typing of the graph <m>G</m> by <m>Sch</m> is:
	  <ul>
	    <li>
	      <m>typing = { (<span class="pre">inst:Issue1, &lt;TE_Issue&gt;</span>), (<span class="pre">inst:User2, &lt;TE_User&gt;</span>), (<span class="pre">inst:User2, &lt;TE_Employee&gt;</span>) }</m>
	    </li>
	  </ul>
	</p>
      </div>

      <h3>Value Expressions</h3>
      <h4>Abstract Syntax</h4>
      <p>
	Value expressions are associated with shape labels by the <m>def</m> function of a shapes schema.
	Value expressions are defined by the following abstract syntax.
      </p>
      <div class="abstrsynt">
	<as>ValueExpression_ ::= TripleExprRef_</as></br>
	<as>| NodeConstraint_</as></br>
	<as>| ConjunctiveValueExpr_</as></br>
	<as>| DisjunctiveValueExpr_</as></br>
	<as>| NegatedValueExpr_</as></br>
	<as>TripleExprRef_ ::=</as> a triple expression label from <as>TELabels</as></br>
	<as>NodeConstraint_ ::=</as> a subset of <as>IRI &cup; Lit &cup; {blank}</as></br>
	<as>ConjunctiveValueExpr_ ::= ValueExpression_ 'AND' ValueExpression_</as></br>
	<as>DisjunctiveValueExpr_ ::= ValueExpression_ 'OR' ValueExpression_</as></br>
	<as>NegatedValueExpr_ ::= 'NOT' ValueExpression_</as>
      </div>
      <p>
	That is, a value expression is any Boolean combination of two kinds of atomic components:
	<ul>
	  <li>
	   a triple expression label (<m>TripleExprRef</m>) that refers to a triple expression defined in the shapes schema, or
	  </li>
	  <li>
	    a node constraint (<m>NodeConstraint</m>) that defines the set of allowed values for a node. 
	    In shapes schemas, a node constraint can be an arbitrary set that contains IRIs, literal values, or the special value <m>blank</m> that stands for any blank node. 
	    In practice, in ShEx schemas, a node constraint is given as [TODO: reference to ShEx concrete syntax or primer]
	  </li>
	</ul>
      </p>
      
      <div class="Example">
	<p>Let <m>U, V, <span class="pre">int</span></m> be node constraints, that is, subests of <m>IRI &cup; Lit &cup; {blank}</m>, with 
	  <ul>
	    <li>
	      <m>U = { <span class="pre">ex:unassigned, ex:assigned, ex:unknown</span> }</m>
	    </li>
	    <li>
	      <m>V = { <span class="pre">1, 2, 5</span> }</m>
	    </li>
	    <li>
	      <m><span class="pre">int</span></m> the set of all integer values
	    </li>
	  </ul>
	</p>
	<p>
	  Let <m>S</m> and <m>T</m> be a shape labels.<br/>
	</p>
	<p>
	  Examples of value expressions are
	  <ul>
	    <li><m>int AND (NOT V)</m></li>
	    <li><m>U AND (S AND (NOT T))</m></li> 
	  </ul>
	</p>
      </div>

      <h4>Semantics</h4>
      <p>
	A value expression defines a property of a single node.
	The semantics of a value expression is defined relative to a typing.
      </p>

      <p>
	Formally, let <m>Sch = (SLabels, TELabels, def)</m> be a shapes schema and <m>G</m> be a graph.
	For a <m>node</m> in <m>Nodes(G)</m>, a <m>typing</m> of <m>G</m> by <m>Sch</m>, and a value expression <m>VExpr</m>, we say that <m>node</m> satisfies <m>VExpr</m> with <m>typing</m>, written <m>typing, node &vdash; VExpr</m>, as defined recursively on the structure of <m>VExpr</m> on the figure above, where:
	<ul>
	  <li>
	    <m>S</m> is a <as>TripleExprRef</as> (in the ve-shaperef rule);
	  </li>
	  <li>
	    <m>NC</m> is a <as>NodeConstraint</as> (in the ve-nodeconstr and ve-nodeconstr-brank rules); 
	  </li>
	  <li>
	    the <m>typing, node &vdash;/ VExpr<sub>2</sub></m> in the premise of the ve-neg rule means that it is impossible to construct a proof for <m>typing, node &vdash; VExpr</m>.
	  </li>
	</ul>
      </p>
      
      <p>
	<img src="images/ve-rules.png" style="width: 60%"/>
      </p>

      <div class="Example">
	<p>
	  Let <m>U, V, <span class="pre">int</span>, S, T</m> be as in the previous example.
	</p>
	<p>
	  Whatever the value of <m>typing</m>, it holds
	  <ul>
	    <li>
	      <m>typing, 3 &vdash; int AND (NOT V)</m>
	    </li>
	  </ul>
	</p>

	<p> If <m>typing = { (<span class="pre">ex:assigned</span>, S), (<span class="pre">ex:assigned</span>, T), (<span class="pre">ex:unknown</span>, S), (<span class="pre">ex:somenode</span>, S) }</m>, then 
	  <ul>
	    <li>
	      <m>typing, ex:assigned &vdash;/ U AND (S AND (NOT T))</m><br/>
	    </li>
	    <li>
	      <m>typing, ex:unknown &vdash; U AND (S AND (NOT T))</m><br/>
	    </li>
	    <li>
	      <m>typing, ex:somenode &vdash;/ U AND (S AND (NOT T))</m><br/>
	    </li>
	  </ul>
	</p>
      </div>

      <h3>Triple Expressions</h3>
      
      <p>
	Triple expressions are associated with triple expression labels in a shapes schema.
	They are defined by the following abstract syntax.
      </p>
      <div class="abstrsynt">
	<as>TripleExpression_ ::= EmptyTripleExpr_</as><br/>
	<as>| TripleConstraint_</as><br/>
	<as>| SomeOfTripleExpr_</as><br/>
	<as>| EachOfTripleExpr_</as><br/>
	<as>| RepeatedTripleExpr_</as><br/>
	<br/>
	<as>EmptyTripleExpr_ ::= 'EMPTY'</as></br>
	<as>TripleConstraint_ ::= PropertySet_ ShapeRef_</as><br/>
	<as>PropertySet_ ::= </as> a finite or co-finite subset of <as>Prop &cup; InvProp</as><br/>
	<as>ShapeRef_ ::= </as> a shape label from <as>SLabels</as><br/>
	<br/>
	<as>SomeOfTripleExpr_ ::= TripleExpression_ '|' TripleExpression_</as><br/>
	<as>EachOfTripleExpr_ ::= TripleExpression_ ';' TripleExpression_</as><br/>
	<br/>
	<as>RepeatedTripleExpr_ ::= TripleExpression_ '[' MinCard_ ';' MaxCard_ ']'</as><br/>
	<as>MinCard_ ::= </as> a natural number<br/>
	<as>MaxCard_ ::= </as> a natural number or <as>'*'</as><br/>
      </div>
      <p>
	That is, an atomic triple expression can be
	<ul>
	  <li>
	     the empty triple expression, that is only satisfied by a node which neighbourhood is empty, or
	  </li>
	  <li>
	    a triple constraint, that defines a constraint on a single triple. 
	    A triple constraint is composed of a set of properties or inverse properties, that define the allowed values for the predicate of a triple, as well as a reference to value constraint, that is to be satisfied by the node in the triple opposite to the focus node.
	  </li>
	</ul>
      </p>
      <p>
	Then, a triple expression can be obtained by combining two triple expressions using the some-of binary operator, denoted <m>|</m>, and the each-of binary operator, denoted as a semicolon <m>;</m>. Intuitively, 
	<ul>
	  <li>
	    a some-of triple expression is satisfied if the neighbourhood of the node satisfies one of its sub-expressions, and
	  </li>
	  <li>
	    an each-of triple expression is satisfied if the neighbourhood of the focus node can be split in two parts, and each part satisfies one of the sub-expressions.
	  </li>
	</ul>
	These however should not be considered as disjunction and conjunction, as we will see later on when the semantics will be formally defined.
      </p>
      <p>
	Finally, a triple expression can be repeated by specifying a minimal cardinality that is a natural number, and a maximal cardinality that is a natural number of an unbounded value denoted as a star <m>*</m>. 
	Intuitively, a repeated triple expression <m>TExpr[min;max]</m> is satisfied if the neighbourhood of the focus node can be split into <m>n</m> parts such that <m>min &lte; n &gte; max</m>  and each of the parts satisfies the inner triple expression <m>TExpr</m>.
      </p>
    

      <div class="Example">
	TODO: an example of a triple expression that is part of the translation to be done for the ShEx schema.
      </div>
<!--       <div class="Example"> -->
<!-- 	<p> -->
<!-- 	  Parentheses are used for delimiting sub-expressions. -->
<!-- 	  Note that, as we will see in the sequel, the some-of and each-of operators are associative and commutative, therefore we use them with any number of sub-expressions without parentheses. -->
<!-- 	  That is, for instance, <span class="pre">(x | y) | z</span> is equivalent to <span class="pre">x | (y | z)</span>, so we write simply <span class="pre">x | y | z</span>, and similarly for the each-of operator. -->
<!-- 	</p> -->
<!-- 	<!-\-<p> -\-> -->
<!-- 	<!-\-   Let a set of shape labels <m>SLabels = { <span class="pre">&lt;UserShape&gt;, &lt;ClientShape&gt; &lt;TesterShape&gt;, &lt;ProgrammerShape&gt;</span> }</m>. -\-> -->
<!-- 	<!-\- </p> -\-> -->
<!-- 	<p> -->
<!-- 	  Let a set of value constraint labels <m>VCLabels = { <span class="pre">&lt;VC_A&gt;, &lt;VC_B&gt;, &lt;VC_string&gt;,  &lt;VC_int&gt; }</m> -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  Let <span class="pre">ex:p, ex:q, foaf:name, foaf:firstName, foaf:lastName</span> be properties (that is, IRI), for some prefixes <span class="pre">ex:</span> and <span class="pre">foaf:</span>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  The following are examples of relatively simple triple expressions. -->
<!-- 	  <ul> -->
<!-- 	    <li> -->
<!-- 	      Triple constraints, with <m>P = (Prop &cup; InvProp) \ {<span class="pre">ex:p</span>}</m> -->
<!-- 	      <ul> -->
<!-- 		<li> -->
<!-- 		  <span class="pre">{^ex:p}   &lt;VC_A&gt;</span> -->
<!-- 		</li> -->
<!-- 		<li> -->
<!-- 		  <span class="pre">{foaf:name, foaf:lastName}  &lt;VC_string&gt;</span> -->
<!-- 		</li> -->
<!-- 		<li> -->
<!-- 		  <span class="pre"><m>P</m>  &lt;VC_int&gt;</span> -->
<!-- 		</li> -->
<!-- 	      </ul> -->
<!-- 	      The first two triple constraints use finite sets of properties, the last one uses a co-finite set of properties. -->
<!-- 	    </li> -->
<!-- 	    <li> -->
<!-- 	      A repeated triple expression, which sub-expression is a triple constraint, with minimal cardinality 1 and maximal cardinality * -->
<!-- 	      <ul> -->
<!-- 		<li> -->
<!-- 		   <span class="pre">( {ex:p}  &lt;VC_int&gt; )[1;*]</span><br/> -->
<!-- 		</li> -->
<!-- 	      </ul> -->
<!-- 	    </li> -->
<!-- 	    <li> -->
<!-- 	      An each-of operator on top of three triple constraints: -->
<!-- 	      <ul> -->
<!-- 		<li> -->
<!-- 		  <span class="pre">{ex:p} &lt;VC_A&gt; , {ex:q} &lt;VC_int&gt; , {ex:p}  &lt;VC_B&gt;</span>   -->
<!-- 		</li> -->
<!-- 	      </ul> -->
<!-- 	    </li> -->
<!-- 	    <li> -->
<!-- 	      A some-of operator on top of one triple constraint and one each-of sub-expression, the latter composed of one repeated triple constraint and one triple constraint. -->
<!-- 	      <ul> -->
<!-- 		<li> -->
<!-- 		  <span class="pre">{foaf:name} &lt;VC_string&gt; | <br/> -->
<!-- 		    ( ({foaf:firstName} &lt;VC_string&gt;)[1;*] , {foaf:lastName}  &lt;VC_string&gt; )</span>   -->
<!-- 		</li> -->
<!-- 	      </ul> -->
<!-- 	    </li> -->
<!-- 	  </ul> -->
<!-- 	</p> -->
<!--       </div> -->

<!--       <div class="Example"> -->
<!-- 	<p> -->
<!-- 	  We now give a more complex triple expression. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  Let a set of value constraint labels <m>VCLabels = { <span class="pre">&lt;VC_UserAndClient&gt;, &lt;VC_Programmer&gt;, &lt;VC_Tester&gt;,  &lt;VC_User&gt;, &lt;VC_NotProgrammerTester&gt;, &lt;VC_AllNode&gt;</span> }</m> -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  Let <span class="pre">is:reproducedBy, is:reportedBy, is:affectedBy</span> be properties for some prefix <span class="pre">is:</span>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  An example of a triple expression is (the leading numbers are line numbers for future reference): -->
<!-- <pre> -->
<!-- 1.    {is:reportedBy}    &lt;VC_UserAndClient&gt;              ; -->
<!-- 2.    {is:reproducedBy}  &lt;VC_Tester&gt;                     ; -->
<!-- 3.    {is:reproducedBy}  &lt;VC_Programmer&gt;                 ; -->
<!-- 4.  ( {^is:affectedBy}   &lt;VC_User&gt;                )[1;*] ;  -->
<!-- 5.    {is:reproducedBy}  &lt;VC_NotProgrammerTester&gt;        ; -->
<!-- 6.  ( OtherProp          &lt;VC_AllNode&gt;             )[0;*]       -->
<!-- </pre> -->
<!-- where <m><span class="pre">OtherProp</span> = (Prop &cup; InvProp) \ { <span class="pre">is:reportedBy, is:reproducedBy, ^is:affectedBy</span> }</m> is the set that contains all properties and inverse properties except for <span class="pre">is:reportedBy, is:reproducedBy, ^is:affectedBy</span>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  The above triple expression is an each-of expression on top of 6 sub-expressions, one on each line. -->
<!-- 	  The sub-expressions on lines 1., 2., 3., 5. are triple constraints. -->
<!-- 	  The sub-expression on line 4. is a repeted triple expression, with minimum cardinality 1 and maximum cardinality *. -->
<!-- 	  The sub-expression on line 6. is also a repeated triple expression, with minimum cardinality 0 and maximum cardinaliy *. -->
<!-- 	</p> -->
<!--       </div> -->

      <p>
	A triple expression defines a property on the neighbourhood of a node in a graph.
      </p>

      <p>
	A set of triples <m>Neigh</m> is called a neighbourhood set of triples if there is a <m>node</m> such that all triple in <m>Neigh</m> is either of the form <m>(node, prop, node')</m> or of the form <m>(node, ^prop, node')</m> for some <m>node'</m> in <m>G</m> and some property <m>prop</m> or inverse property <m>^prop</m>.
	Intuitively, a neighbourhood set of triples is a subset of <m>neigh(G,node)</m> for some <m>node</m> in the graph <m>G</m>.
      </p>
      
      <p>
	For a neighbourhood set of triples <m>Neigh</m> from the graph <m>G</m>, a triple expression <m>TExpr</m>, and a <m>typing</m> of <m>G</m> by <m>Sch</m>, we say that <m>Neigh</m> satisfies <m>TEXpr</m> for <m>typing</m>, written <m>typing, Neigh &vdash; TExpr</m>, as defined above recursively on the structure of <m>TExpr</m>, where
	<ul>
	  <li>
	    <m>P</m> is a subset of <m>Prop &cup; InvProp</m> and <m>V</m> is a shape label (in rule te-tripleconstr);
	  </li>
	  <li>
	    <m>&uplus;</m> is the disjoint union of sets (in rules te-eachof and te-repet); 
	  </li>
	  <li>
	    <m>min</m> and <m>max</m> are the minimum, respectively maximum cardinality in a <m>RepetedTripleExpr</m> (in rule te-repet).
	  </li>
	</ul>

      </p>

      <p>
	<img src="images/te-rules.png" style="width: 90%"/>
      </p>

      <p>
	A <m>typing</m> of <m>G</m> by <m>Sch</m> is called locally valid if for all node-label association <m>(node, T)</m> in <m>typing</m>, it is the case that <m>typing, neigh(node) &vdash; def(T)</m>.
      </p>
      
      <div class="Example">
	<p>
	  TODO: examples of a satisfiability of triple expressions
	</p>
      </div>


      <h3>Shapes Schemas with Stratified Negation</h3>
      <p>
	As we can see from the syntax, value expressions refer to shapes (through a <as>TripleExprRef_</as>), and triple expressions refer to value expressions (through a <as>ValueExprRef_</as> in a triple constraint). 
	In order to avoid undesirable interaction between recursion and the negation in value expressions, we consider shapes schemas with stratified negation only, as defined in the sequel.
      </p>
      
      <p>
	We start by some definitions that will allow us to define the stratification.
      </p>

      <p>
	If <m>VExpr</m> is a value expression, and <m>S</m> is a triple expression label, we say that <m>S</m> appears negated in <m>VExpr</m> if <m>S</m> appears in <m>VExpr</m> under an odd number of negations, that is, under an odd number of occurrences of the <m>NOT</m> operator.
	We then define two dependency relations over the triple expression labels in a shapes schema, namely positive dependency <m>dep+</m>, and negative dependency <m>dep-</m>.
	Formally, for a shapes schema <m>Sch = (SLabels, TELabels, def)</m>, and two triple expression labels <m>S</m> and <m>T</m> in <m>TELabels</m>, we define:
	<ul>
	  <li>
	    <m>dep+(S,T)</m> if there exists a shape label <m>V</m> such that <m>V</m> appears in <m>def(S)</m>, and <m>T</m> appears in <m>def(V)</m>, but <m>T</m> does not appear negated in <m>def(V)</m>. 
	    Recall that <m>def(S)</m> is a triple expression that defines the triple expression label <m>S</m>, and <m>def(V)</m> is a value expression that defines the shape label <m>V</m>.
	  </li>
	  <li>
	    <m>dep-(S,T)</m> if there exists a shape label <m>V</m> such that <m>V</m> appears in <m>def(S)</m>, and <m>T</m> appears negated in <m>def(V)</m>.
	  </li>
	</ul>	
      </p>
      <p>
	Then the dependency relations <m>dep+</m> and <m>dep-</m> define a dependency graph between triple expression labels of the shapes schema <m>Sch</m>.
	We say that the shapes schema <m>Sch</m> is with stratified negation if its dependency graph does not contain a cycle that contains a <m>dep-</m> edge.
      </p>
      
      <div class="Example">
	<p>
	  TODO: An example of a shapes schema and its dependency graph.
	</p>
      </div>

      <p>
	It is well known that in case of stratified negation, one can define what is called a stratification. 
	If the schema <m>Sch = (SLabels, TELabels, def)</m> is with stratified negation, then there exists a natural number <m>k</m> and a partitioning function <m>strat: TELabels &#8594; 1..k</m> that with every triple expression label from <m>TELabels</m> associates a natural number between <m>1</m> and <m>k</m>, called the stratum of that label. 
	Moreover, the partitioning function <m>strat</m> satisfies the following property: for all triple expression labels <m>S,T</m> in <m>TELabels</m>, if <m>dep-(S,T)</m>, then <m>strat(S) &gt; strat(T)</m>, and if <m>dep+(S,T)</m>, then <m>strat(S) &ge; strat(T)</m>. 
	Such a partitioning function is called a stratification.
      </p>
      <p>
	A stratification guarantees the following property: a triple expression label can depend negatively only on triple expression labels that are in strictly lower stratums, and a triple expression label can depend positively only on triple expression labels that are on lower or on the same stratum.
      </p>

      <div class="Example">
	<p>
	  TODO: an example of stratificaiton
	</p>
      </div>

      <p>
	Shapes schemas with stratified negation are guaranteed to have well founded semantics as it will be defined in the sequel.
	It is not necessarily the case for shapes schemas that might contain cycles of negative dependencies.
	Therefore, a shapes schema is allowed only if it has stratified negation, and we consider only shapes schemas with stratified negation in the sequel.
	Remark that it is easy to check whether a schema is with stratified negation: it is enough to construct the dependency graph, and check that it does not contain any cycle that goes through a negative dependency.
      </p>

      <h3>Maximal Typing</h3>
      <p>
	Stratified schemas allow for the definition of a unique typing, which is the one used to determine whether a node in a graph satisfies the constraint defined by a value expression.
	This typing is called the maximal typing, as intuitively it forces to add in the typing every provable node-label association.
      </p>

      <p>
	The maximal typing is defined using a stratification. 
	Let <m>Sch = (SLabels, TELabels, def)</m> be a schema, <m>strat: TELabels &#8594; 1..k</m> be a stratification for <m>Sch</m>, and <m>G</m> be a graph.
	We define a sequence <m>Sch<sub>1</sub>, ...., Sch<sub>k</sub></m> of sub-schemas of <m>Sch</m> following the stratification <m>strat</m>, as follows. 
	For all <m>i</m> in <m>1..k</m>, <m>Sch<sub>i</sub> = (SLabels<sub>i</sub>, TELabels<sub>i</sub>, def<sub>i</sub>)</m> where <m>TELabels<sub>i</sub></m> is the subset of <m>TELabels</m> composed of the triple expression labels on the stratums <m>1..i</m>, and <m>SLabels<sub>i</sub></m> and <m>def<sub>i</sub></m> are restricted on these labels only.
	Formally, 
	<ul>
	  <li>
	    <m>TELabels<sub>i</sub> = strat<sup>-1</sup>(1) &cup; ... &cup; strat<sup>-1</sup>(i)</m>,
	  </li>
	  <li>
	    <m>SLabels<sub>i</sub></m> are the shape labels that appear in <m>def(S)</m> for some <m>S</m> in <m>TELabels<sub>i</sub></m>, and
	  </li>
	  <li>
	    <m>def<sub>1</sub></m> is <m>def</m> restricted on <m>TELabels<sub>i</sub></m> and <m>SLabels<sub>i</sub></m> only.
	  </li>
	</ul>
	It follows from this definition that <m>Sch<sub>k</sub></m> is equal to <m>Sch</m>.
      </p>
      
      <p>
	Then we define a sequence of typings <m>typing<sub>1</sub>, ..., typing<sub>k</sub></m> such that for all <m>i</m> in <m>1..k</m>, <m>typing<sub>1</sub></m> is the maximum typing for <m>Sch<sub>i</sub></m>.
	Formally, 
	<ul>
	  <li>
	    <m>typing<sub>1</sub></m> is the union of all locally valid <m>typing</m>s of <m>G</m> by <m>Sch<sub>1</sub></m>;
	  </li>
	  <li>
	    for <m>i</m> in <m>2..k</m>, <m>typing<sub>i</sub></m> is the union of all locally valid typings of <m>G</m> by <m>Sch<sub>i</sub></m> that coincide with <m>typing<sub>i-1</sub></m> on the <m>TELabels<sub>i-1</sub></m>.
	  </li>
	</ul>
      </p>
      
      <p>
	Note that because <m>Sch</m> is stratified and because of the way the sub-schemas <m>Sch<sub>i</sub></m> were defined, it is the case that all the typings <m>typing<sub>i</sub></m> are locally valid.
      </p>

      <p>
	The typing <m>typing<sub>k</sub></m> as defined above is called the maximal typing of <m>G</m> by <m>Sch</m>.
      </p>

      <div class="Example">
	<p>
	  TODO: an example of the sequence of typings
	</p>
      </div>
      
    </section>
    
    <section id="translation-shex-shapes">
      <h2>Translation of a ShEx Schema into a Shapes Schema</h2>
      <p>
	We give here the abstract syntax of a ShEx schema and describe how it is translated to a shapes schema.
      </p>

      <div class="Example">
	<p>
	  The following shapes schema is the translation of TODO: refererence to the previous example to a shapes schema.
	</p>
	<p>
	  We use <span class="pre">:=</span> as a separator between a label and its definition.
	</p>
	
<div>
<div style="float:left; border-style:dotted; margin-right: 30px; padding:10px" >
<pre>
&lt;VE_0&gt;  := IRI &cup; Lit &cup; {blank}
&lt;VE_1&gt;  := {ex:unassigned, ex:assigned}
&lt;VE_2&gt;  := @&lt;UserShape&gt;
&lt;VE_3&gt;  := xsd:dateTime
&lt;VE_4&gt;  := @&lt;EmployeeShape&gt; 
&lt;VE_5&gt;  := xsd:dateTime OR xsd:date
&lt;VE_6&gt;  := @&lt;IssueShape&gt;
&lt;VE_7&gt;  := {foaf:Person}
&lt;VE_8&gt;  := {ex:User}
&lt;VE_9&gt;  := xsd:string
&lt;VE_10&gt; := IRI
&lt;VE_11&gt; := PATTERN "^tel:\\+33"
&lt;VE_12&gt; := PATTERN "\\.fr$"
&lt;VE_13&gt; := PATTERN "^tel:\\+44"
&lt;VE_14&gt; := PATTERN "\\.uk$"

&lt;NC_1&gt;  := PATTERN "^http:/example.org/.*"

&lt;VE_User_Extra_1&gt;  := NOT{foaf:Person} AND NOT{ex:User}

&lt;IssueShape&gt;    := &lt;TE_Issue&gt; 
&lt;UserShape&gt;     := &lt;NC_1&gt; AND &lt;TE_User&gt; 
&lt;EmployeeShape&gt; := &lt;TE_Employee_1&gt; AND &lt;TE_Employee_2&gt;

&lt;TE_Issue&gt; := {
    {ex:state}      &lt;VE_1&gt; ;
    {ex:reportedBy} &lt;VE_2&gt; ;
    {ex:reportedOn} &lt;VE_3&gt; ;
    (
        {ex:reproducedBy} &lt;VE_4&gt; ;
        {ex:reproducedOn} &lt;VE_5&gt;
    )?
    {ex:related}    &lt;VE_6&gt;*  ;
    {^ex:related}   &lt;VE_6&gt;*
}

&lt;TE_User&gt;  := {
    {rdf:type}  &lt;VE_7&gt; ;
    {rdf:type}  &lt;VE_8&gt; ;
    (
        {foaf:name}       &lt;VE_9&gt;
    |
        {foaf:givenName}  &lt;VE_9&gt;+ ;
        {foaf:familyName} &lt;VE_9&gt;
    );
    {foaf:mbox}           &lt;VE_10&gt;  ;

    {rdf:type}            &lt;VE_User_Extra_1&gt; * ;
    OP_User               &lt;VE_0&gt; *
}

&lt;TE_Employee_1&gt; := {
    {foaf:phone} &lt;VE_10&gt;* ;
    {foaf:mbox}  &lt;VE_10&gt; ;

    OP_Empl_1    &lt;VE_10&gt;* 
}

&lt;SE_Employee_2&gt; := {
    ( {foaf:phone} &lt;VE_11&gt; ;
      {foaf:mbox}  &lt;VE_12&gt; )? ;
    ( {foaf:phone} &lt;VE_13&gt; ;
      {foaf:mbox}  &lt;VE_14&gt; )?

    OP_Empl_2    &lt;VE_0&gt;* 
}

# with OP_User = (Prop &cup; InvProp) \ 
                    {rdf:type, foaf:name, foaf:givenName, foaf:familyName, foaf:mbox}
# with OP_Empl_1 = (Prop &cup; InvProp) \ {foaf:phone, foaf:mbox}
# with OP_Empl_2 = (Prop &cup; InvProp) \ {foaf:phone, foaf:mbox}
</pre>
</div>
<div style="float:left; border-style:dotted; margin-right: 30px; padding:10px; clear:right">
<pre>





&lt;IssueShape&gt;
CLOSED ^CLOSED {                 
    ex:state [ex:unassigned ex:assigned] ; 
    ex:reportedBy @&lt;UserShape&gt;           ;   
    ex:reportedOn xsd:dateTime           ;         
    (                                   
      ex:reproducedBy @&lt;EmployeeShape&gt; ;  
      ex:reproducedOn xsd:dateTime OR xsd:date 
    )?                                   ;
    ex:related  @&lt;IssueShape&gt;*           ;
    ^ex:related @&lt;IssueShape&gt;*
}

&lt;UserShape&gt;  PATTERN "^http:/example.org/.*"
EXTRA rdf:type  {
    rdf:type [foaf:Person] ;
    rdf:type [ex:User] ;
    (                                   
       foaf:name xsd:string             
     |                                  
       foaf:givenName xsd:string+ ;      
       foaf:familyName xsd:string
    );     
    foaf:mbox IRI              
}

&lt;EmployeeShape&gt; {        
    foaf:phone IRI*;          
    foaf:mbox IRI             
} AND {
    ( foaf:phone PATTERN "^tel:\\+33" ; 
      foaf:mbox  PATTERN "\\.fr$" )?   ;
    ( foaf:phone PATTERN "^tel:\\+44" ; 
      foaf:mbox  PATTERN "\\.uk$")?
}




















</pre>
</div>
<div style="clear:both;"> </div>
</div>
	<!-- <p> -->
	<!--   Every <as>ValueExpression</as> that appears in some triple constraint of the ShEx schema yields a named <as>ValueConstraintDefinition</as> in the shapes schema. -->
	<!--   The value constraint is named with a fresh shape label; in this example we use <span class="pre">&lt;VE_1&gt;, &lt;VE_2&gt;, ... &lt;VE_13&gt;</span>. -->
	<!--   Note that the translation is syntactic: if the same value expression appears several times, it will be duplicated, as for instance the <span class="pre">&lt;VE_7&gt;, &lt;VE_8&gt;, &lt;VE_9&gt;</span> value expressions that are all defined as the set of all <span clas="pre">xsd:string</span>. -->
	<!-- </p> -->

	<!-- <p> -->
	<!--   Every <as>NodeConstraint</as> that appears on top level of some <as>ShapeExpression</as> from the ShEx schema also yields a <as>ValueConstraintDefinition_</as>. -->
	<!--   It is given a fresh shape label; in this example there is a unique such value constraint definition which label is <span class="pre">&lt;NC_1&gt;</span>. -->
	<!--   The corresponding definition is set from the node constraint. -->
	<!-- </p> -->

	<!-- <p> -->
	<!--   Every <as>ShapeLabel</as> together with its <as>ShapeExpression</as> from the ShEx schema yields a <as>ValueConstraintDefinition_</as> in the shapes schema. -->
	<!--   The <as>ValueConstraintDefinition_</as> uses the same label, and the corresponding definition is a conjunction of all the <as>NodeConstraint</as> and <as>ShapeDefinition</as> from the <as>ShapeExpression</as>. -->
	<!--   In this example, we have the three node constraint definitions <span class="pre">&lt;IssueShape&gt;, &lt;UserShape&gt;, &lt;EmployeeShape&gt;</span>. -->
	<!-- </p> -->

	<!-- <p> -->
	<!--   Every <as>ShapeDefinition</as> from the ShEx schema yields a <as>ShapeDefinition_</as> in the shapes schema.  -->
	<!--   These shape definitions are given fresh labels, in this example we have <span class="pre">&lt;SE_IssueShape&gt;, &lt;SE_UserShape&gt;, &lt;SE_EmployeeShape_1&gt;,  &lt;SE_EmployeeShape_2&gt;</span>. -->
	<!--   The <as>TripleExpression_</as> in this shape definition integrates not only the <as>TripleExpr</as> that appears in the ShEx schema, but also the <m>CLOSED</m> and <m>EXTRA</m> modifiers.  -->
	<!--   This is where the sets of properties in the triple constraints are used. -->
	<!--   In the sequel we explain how these <as>TripleExpression</as>s are obtained. -->
	<!-- </p> -->

	<!-- <p> -->
	<!--   First, every <as>TripleConstraint</as> from the ShEx schema yields a <as>TripleConstraint_</as> of the shapes schema.  -->
	<!--   If <as>TripleConstraint</as><m>(prop, ve)</m> is a <as>TripleConstraint</as> in the ShEx schema, it yields <as>TripleConstraint</as><m>({prop}, <span class="pre">@&lt;VE_x&gt;</span>)</m>, where <m>{prop}</m> is a singleton set containing the property from the ShEx triple constraint, and <span class="pre">&lt;VE_x&gt</span> is the shape label for <m>ve</m>. -->
	<!-- </p> -->
	
	<!-- <p> -->
	<!--   TODO: the explanation is to be continued. -->
	<!-- </p> -->
	

     </div>
    </section>

    <section id="validation-for-shex">
      <h2>Validation of a Graph against a ShEx Schema</h2>
      
      <p>
	Let <m>Shex</m> be a ShEx schema with set <m>ShapeNames</m> of shape names.
	For a graph <m>G</m>, a validation problem is defined as a set <m>val</m> of node-label name associations.
	That is, <m>val</m> is a subset of <m>Nodes(G) &times; ShapeNames</m>.
	Then the validation problem consists in checking whether for every node-label name association <m>(node, sname)</m> in <m>val</m>, it is the case that <m>node</m> satisfies the constraint defined by <m>sname</m>.
      </p>

      <p>
	Formally, let <m>Sch</m> be the shapes schema that corresponds to <m>Shex</m>, and for every shape name <m>sname</m> in <m>Shex</m>, let <m>valConstr(sname)</m> be the corresponding value constraint name in <m>Sch</m>.
	Then the answer to the validation problem <m>val</m> is yes if and only if for all <m>(node, sname)</m> in <m>val</m>, it is the case that <m>typing, node &vdash; valConstr(sname)</m>, where <m>typing</m> is the maximal typing of <m>G</m> by <m>Sch</m>.
      </p>

      <p>
	Remark that the validation problem does not necessarily require to compute <m>typing</m> entirely.
	Only a portion of <m>typing</m> can be computed, starting from <m>val</m> and adding only the node-label associations that are necessary for proving, or disproving, the node-label name associations from <m>val</m>.
      </p>

    </section>

    <footer>
      <p>
        
      </p>
    </footer>
    

    <script>
      $("m").wrapInner("<span class='math'/>").children(0).unwrap();
    </script>
    <script>
      $("as").wrapInner("<span class='as'/>").children(0).unwrap();
    </script>
  </body>
</html>
