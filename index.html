<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>Semantics of Shape Expressions</title>
    <script src="http://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>
    <link rel="stylesheet" href="css/wgio.min.css"/>
    <style>
      .todo {
      color: red;
      }

      

      .Definition{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F0F0;
      }

      .abstrsynt{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F8F8;
      line-height: 1.5;
      }
      .emph{
      font-style: italic;
      }

      .textbf{
      font-weight: bold;
      }
      .math{
      font-style: normal;
      font-family: sans-serif;
      }

      .mathbf{
      font-weight: bold;
      font-family: sans-serif;
      }

    </style>
  </head>
  <body>
    <h1>Semantics of Shape Expressions</h1>
    <b> Author: Iovka Boneva </b><br>
    <b> Version: Sept 11, 2015 </b> 


    <h2>Abstraction of RDF Graphs</h2>
    <p>
      A shape definition allows to define constraints on the neighborhood of a focus node in the RDF graph. Because of inverse triple constraint, we consider the neighborhood as being composed of both outgoing and incoming edges, that is of both triples that have the focus node as subject, and triples that have the focus node as an object. 
    </p>
    <p>
      In order to handle incoming and outgoing edges uniformly, we consider the following abstraction of RDF graphs. Let <span class="math">Prop</span> be a set of properties, that in practice correspond to the set of IRI, and let <span class="math">^Prop</span> be a set of  <span class="emph">inverse properties</span>. An inverse property is simply a property decorated by a hat <span class="math">^</span>, that is, if <span class="math">prop</span> is a property, then <span class="math">^prop</span> is an inverse property. 
    </p>
    <p>
A <span class="emph">graph</span> is defined by a set <span class="math">Nodes</span> of nodes, a set <span class="math">Edges</span> of edges, and  <span class="math">val</span> a value function. The nodes of the graph are abstract entities. The value function <span class="math">val</span> associates, with every  <span class="math">node</span> in <span class="math">Nodes</span>, either an IRI, or a literal value, or a special value  <span class="mathbf">b</span> that stands for a blank node. Finally, every   <span class="math">edge</span> in <span class="math">Edges</span> is a triple of the form  <span class="math">(node, prop, node')</span> or <span class="math">(node', ^prop, node)</span>, where <span class="math">prop</span> is a property and <span class="math">^prop</span> is an inverse property.
    </p>
    <p>
      Given a set of triples defining an RDF graph, the above abstraction is obtained by: 
      <ul>
	<li>For all IRI <span class="math">X</span> that appears in a subject or object position in some triple, there is <span class="math">node<sub>X</sub></span> in <span class="math">Nodes</span> s.t. <span class="math">val(node<sub>X</sub>) = X</span>.</li>
	<li>For all blank node <span class="math">B</span> that appears in some triple, there is a <span class="math">node<sub>B</sub></span> in <span class="math">Nodes</span> s.t. <span class="math">val(node<sub>B</sub>) = </span><span class="mathbf">b</span>.</li>
	<li>For all triple <span class="math">(E<sub>1</sub>, P, E<sub>2</sub>)</span>, the set <span class="math">Edges</span> contains the two edges  <span class="math">(node<sub>E<sub>1</sub></sub>, P, node<sub>E<sub>2</sub></sub>)</span> and <span class="math">(node<sub>E<sub>2</sub></sub>, ^P, node<sub>E<sub>1</sub></sub>)</span>. </li>
      </ul>
    </p>

    <p>
      Thus, we are going to write <span class="math">(node, q, node')</span> for an edge, where <span class="math">q</span> is either a property or an inverses property. 
    </p>

    <p>
      Given a <span class="math">node</span> in a graph, its <span class="emph">neighborhood</span> is the set of edges of the form <span class="math">(node, prop, node')</span> and <span class="math">(node', ^prop, node)</span>, for some property <span class="math">prop</span> or inverse property <span class="math">^prop</span>. It is denoted <span class="math">neigh(node)</span>
    </p>

    <header>
      <h2>Syntax of Shape Expression Schema</h2>
    </header>

    <p>
      A shape expression allows to define constraints on the neighborhood of an identified node, called <span class="emph">focus node</span>, within an RDF graph. It is defined by the following abstract syntax.
    </p>
    
    <div class="abstrsynt">
      <span class="math" id="as-ShapeExpr">ShapeExpr ::= EmptyShape</span><br>
      <span class="math">| TripleConstraint</span><br>
      <span class="math">| SomeOfShape</span><br>
      <span class="math">| GroupShape</span><br>
      <span class="math">| RepetitionShape</span><br>
    </div>

    <p>
      The <span class="math">empty shape</span> (<span class="math">EmptyShape</span>) is satisfied by an empty neighborhood.
    </p>

    <p>
      The basic component of a shape expression is a triple constraint (<span class="math">TripleConstraint</span>), which is a forward constraint of the form <span class="math">prop K</span>, or an inverse constraint of the form <span class="math">^prop K</span>. A triple constraint is satisfied by a single adjacent edge of the focus node. A forward constraint <span class="math">prop K</span> is satisfied by an outgoing edge labelled by <span class="math">prop</span> and which target node satisfies the constraint defined by <span class="math">K</span>. An inverse constraint <span class="math">^prop K</span> is satisfied by an incoming edge labelled by <span class="math">prop</span> and which source node satisfies the constraint defined by <span class="math">K</span>. The constraint <span class="math">K</span> can define either a set of allowed values, or a shape constraint that refers to other shape definitions. These will be discussed later on.
    </p>

    <div class="abstrsynt">
      <span class="math" id="as-TripleConstraint">TripleConstraint ::= (Property | InvProperty) ValueClass</span><br>
      <span class="math" id="as-Property">Property ::= </span>an <span class="math">IRI</span><br>
      <span class="math" id="as-InvProperty">InvProperty ::= ^Property</span><br>
      <span class="math" id="as-ValueClass">ValueClass ::= ValueSet | ShapeConstr</span><br>
    </div>

    <p>
      A <span class="emph">some-of shape expression</span> (<span class="math">SomeOfShape</span>) allows to define a disjunctive constraint. It is composed by one or more sub-expressions. A some-of expression is satisfied by a set of neighborhood edges if one of its sub-expressions is satisfied.
    </p>

    <p>
      A <span class="emph">group shape expression</span> (<span class="math">GroupShape</span>) is the most complex one. It is also composed by on or more sub-expressions, and is satisfied by a set of neighborhood edges if the set can be split into as many disjoint subsets, and each of these components satisfies the corresponding sub-expression.
    </p>
    
    <div class="abstrsynt">
      <span class="math" id="as-SomeOfShape">SomeOfShape ::= ShapeExpr ('|' ShapeExpr)*</span><br>
      <span class="math" id="as-GroupShape">GroupShape ::= ShapeExpr (',' ShapeExpr)*</span> <br>
    </div>

    <p>
      Finally, a <span class="math">repetition shape expression</span> (<span class="math">RepetitionShape)</span> is composed by an inner sub-expression, and an allowed number of repetitions specified by a possibly unbounded interval of natural values. Its satisfiability is similar to that of a group expression. A set of neighborhood edges satisfies a group expression if it can be split in <span class="math">m</span> disjoint subsets, and each of those satisfies the sub-expression, where <span class="math">m</span> must belong to the interval of allowed repetitions.
    </p>


    <div class="abstrsynt">
      <span class="math" id="as-RepetitionShape">RepetitionShape ::= ShapeExpr Cardinality</span> <br>
      <span class="math" id="as-Cardinality">Cardinality ::= '[' MinCardinality ';' MaxCardinality ']'</span><br>
      <span class="math" id="as-MinCardinality">MinCardinality ::=</span> a natural number<br>
      <span class="math" id="as-MaxCardinality">MaxCardinality ::=</span> a natural number <span class="math">| 'unbound'</span> <br>
    </div>

    <p>
      Now, a <span class="emph">shape definition</span> specifies a constraint to be satisfied by the entire neighborhood of the focus node. It is composed of: 
      <ul>
	<li>A <span class="emph">set of extra properties</span> (<span class="math">InclPropSet</span>), which is a set of properties or inverse properties, and can be empty.</li>
	<li>An optional <span class="math">CLOSED</span> modifier and an optional <span class="math">^CLOSED</span> modifier, which role is explained below. A shape definition is called <span class="emph">forward closed</span> if it has the <span class="math">CLOSED</span> modifier, and is called <span class="emph">inverse closed</span> if it has the <span class="math">^CLOSED</span> modifier.</li>
	<li>A shape expression <span class="math">ShapeExpr</span>.</li>
      </ul>
    </p>
    
    <p>
      A shape definition distinguishes three different kinds of edges in the neighborhood of a node:
      <ul>
	<li>The edges that are used for satisfying the shape expression. These are all the edges that satisfy some triple constraint in the shape expression. That is, the edges <span class="math">(node, q, node')</span> s.t. there is a triple constraint <span class="math">q K</span>, and <span class="math">node'</span> satisfies the constraint defined by <span class="math">K</span>.</li>
	<li>The extra edges, that are those edges whose property belongs to the set of extra properties, but that satisfy none of the triple constraints in the shape expression (that is, are not in the prevous category of edges).</li>
	<li>The remaining edges, whose label property does not appear neither in some triple constraint, nor in the set of extra properties. No remaining forward edges are allowed if the shape definition is forward closed (<span class="math">CLOSED</span>), and similarly, no remaining inverse edges are allowed if the shape definition is inverse closed (<span class="math">^CLOSED</span>).</ul>
    </p>
    
    <p>
      A<span class="emph">shape expression schema</span> defines a set of <span class="emph">shape labels</span> (also called <span class="emph">shape names</span>), and associates a shape definition with every shape label. Intuitively, a shape expression schema is satisfied by an RDF graph if one can associate shape labels with the nodes of the graph in a way that every node satisfies (the shape definition associated with) all its shape labels. 
    </p>
    
    <div class="abstrsynt">
      <span class="math" id="as-ShapeExpressionSchema">ShapeExpressionSchema ::= (ShapeLabel '&rarr;' ShapeDefinition)+</span><br>
    </div>

    <p>
      We terminate by explaining the constraints defined by <span class="math">ValueClass</span>, which is either a set of values (<span class="math">ValueSet</span>), or a shape constraint (<span class="math">ShapeConstr</span>). A set of values is interpreted as a set that can contain IRIs, literal values, or the special constant <span class="mathbf">b</span> for a blank node. A neighbour node of the focus node satisfies a <span class="math">ValueSet</span> constraint if its value belongs to the corresponding set. A shape constraint <span class="math">ShapeConstr</span> is defined as a disjunction of shape labels, to be interpreted as the shape definition associated with that label within the shape expression schema. A neighbour node of the focus node satisfies a <span class="math">ShapeConstr</span> if its neighbourhood satisfies the shape definition that corresponds to (at least) one of the shape labels in the disjunction.
    </p>

    <div class="abstrsynt">
      <span class="math" id="as-ValueSet">ValueSet ::=</span> set which elements are literals, <span class="math">IRIs</span>, or <span class="mathbf">b</span> <br> 
      <span class="math" id="as-ShapeConstr">ShapeConstr ::= ShapeLabel ('OR' ShapeLabel)*</span><br>
      <span class="math" id="as-ShapeLabel">ShapeLabel ::= </span>an identifier<br>
    </div>

    <p>
      In practice, a <span class="math">ValueSet</span> can be given by enumerating all the possible values, or by any standard way of defining sets of allowed values, such as XML Facets, node kind specification (Literal, NonLiteral, IRI, Blank, …), a regular expression defining the allowed IRIs, etc.
    </p>

    We summarize by recalling the full syntax of shape expression schemas.

    <div class="abstrsynt">
      <span class="math" id="as-ShapeExpressionSchema">ShapeExpressionSchema ::= (ShapeLabel '&rarr;' ShapeDefinition)+</span><br>
      <span class="math" id="as-ShapeDefinition">ShapeDefinition ::= InclPropSet 'CLOSED'? '^CLOSED'? ShapeExpr</span><br>
      <span class="math" id="as-ShapeExpr">ShapeExpr ::= EmptyShape</span><br>
      <span class="math">| TripleConstraint</span><br>
      <span class="math">| SomeOfShape</span><br>
      <span class="math">| GroupShape</span><br>
      <span class="math">| RepetitionShape</span><br>
      <span class="math" id="as-TripleConstraint">TripleConstraint ::= (Property | InvProperty) ValueClass</span><br>
      <span class="math" id="as-SomeOfShape">SomeOfShape ::= ShapeExpr ('|' ShapeExpr)*</span><br>
      <span class="math" id="as-GroupShape">GroupShape ::= ShapeExpr (',' ShapeExpr)*</span> <br>
      <span class="math" id="as-RepetitionShape">RepetitionShape ::= ShapeExpr Cardinality</span> <br>
      <span class="math" id="as-Cardinality">Cardinality ::= '[' MinCardinality ';' MaxCardinality ']'</span><br>
      <span class="math" id="as-MinCardinality">MinCardinality ::=</span> a natural number<br>
      <span class="math" id="as-MaxCardinality">MaxCardinality ::=</span> a natural number <span class="math">| 'unbound'</span> <br>
      <span class="math" id="as-ValueClass">ValueClass ::= ValueSet | ShapeConstr</span><br>
      <span class="math" id="as-ValueSet">ValueSet ::=</span> set which elements are literals, <span class="math">IRIs</span>, or <span class="mathbf">b</span> <br>
      <span class="math" id="as-ShapeConstr">ShapeConstr ::= ShapeLabel ('OR' ShapeLabel)*</span><br>
      <span class="math" id="as-ShapeLabel">ShapeLabel ::= </span>an identifier<br>
      <span class="math" id="as-InclPropSet">InclPropSet ::= (Property | InvProperty)*</span><br>
      <span class="math" id="as-Property">Property ::= </span>an <span class="math">IRI</span><br>
      <span class="math" id="as-InvProperty">InvProperty ::= ^Property</span><br>
    </div>


    <header>
      <h2>Useful Vocabulary and Notations</h2>
    </header>

    <p>
      For the remaining, we assume a fixed shape expression schema <span class="mathbf">Sh</span> which set of labels is <span class="math">Shapes</span>. For a shape label <span class="math">S</span>, we denote <span class="math">definition(S)</span> its shape definition in <span class="mathbf">Sh</span>, and we denote <span class="math">expr(S)</span> the shape expression within the definition of <span class="math">S</span>.
    </p>
    <p>
      The dependency graph of the schema <span class="mathbf">Sh</span> describes how shape labels refer to each others in shape definitions. More formally, the <span class="emph">dependency graph</span> of <span class="mathbf">Sh</span> is an oriented graph which nodes are the elements of <span class="math">Shapes</span>, and that has an arrow from <span class="math">S</span> to <span class="math">T</span> if the shape label <span class="math">T</span> appears in some triple constraint in <span class="math">expr(S)</span>. 
    </p>

    <p>
      Let <span class="math">S</span> be a shape label, and <span class="math">definition(S)</span> be its shape definition. We say that the shape label <span class="math">T</span> <span class="emph">appears negated</span> in <span class="math">definition(S)</span> if there is a some triple constraint <span class="math">q T<sub>1</sub> OR ... OR T<sub>k</sub></span> in <span class="math">expr(S)</span> such that <span class="math">T</span> is one among  <span class="math">T<sub>1</sub>, ..., T<sub>k</sub></span>, and <span class="math">q</span> is an extra property in <span class="math">definition(S)</span>. We denote <span class="math">negated-shapes(S)</span> the set of shape labels that appear negated in <span class="math">definition(S)</span>.
    </p>
    
    <header>
      <h2>Well Defined Schemas</h2>
    </header>
    <p>
      The following syntactic restriction is imposed in order to guarantee well-defined semantics for shape expression schemas. It requires that shape labels that appear negated do not lead to cyclic dependencies between shapes.
    </p> 
    <ul>
      <li>For every shape name <span class="math">S</span> and every shape label <span class="math">T</span> in <span class="math">negated-shapes(S)</span>, it is the case that the sub-graph accessible from <span class="math">T</span> in the dependency graph of <span class="mathbf">Sh</span> is a direct acyclic graph.
      </li>
    </ul>

    <p>
      The following restriction imposes that all extra properties in a shape definition appear in some triple constraint of the same definition. 
    </p>
    <ul>
      <li>For every shape name <span class="math">S</span>, and every extra property <span class="math">p</span> in <span class="math">definition(S)</span>, the property <span class="math">p</span> also appears in some triple constraint in <span class="math">expr(S)</span>. 
      </li>
    </ul>
    <p>
      The latter restriction is not required for well-defined semantics, but rather avoids the need to consider extra properties that do not appear in any triple constraint, as such extra properties are useless (in the sense that they do not modify the satisfiability of the shape definition).
    </p>


    <h2>Declarative Semantics of Shape Expression Schemas</h2>

   
    <h3>Locally Satisfying a Shape Definition</h3>

    <p>
      For every shape definition, we need to refer to the occurrences of its triple constraints. Therefore, we are going to use <span class="math">C<sub>1</sub>, …, C<sub>k</sub></span> as unique names for the triple constraints that appear in a shape definition, where <span class="math">k</span> is the number of triple constraints. The shape definition to which the <span class="math">C<sub>i</sub></span> belong will be always clear from the context. Note that if the same triple constraint appears twice (i.e. same property and same value set or disjunction of shape names), the two occurrences are distinguished and correspond to different <span class="math">C<sub>i</sub></span>. To say it differently, any of the <span class="math">C<sub>i</sub></span> corresponds to a <span class="math">TripleConstraint</span>-position in the abstract syntax tree of a shape definition.
    </p>
    
    <p>
      For every shape definition we identify a set of <span class="emph">triple consumers</span>, that correspond either to some triple constraint, or to an extra property, or to the un-constrained properties of open shape definitions. Intuitively, a <span class="math">node</span> locally satisfies a shape definition if all edge from <span class="math">neigh(node)</span> can be consumed by one of the triple consumers of that shape definition, in a way that satisfies the shape expression of that shape definition. 
    </p>
    <p>
      Formally, let <span class="math">ShDef</span> be a shape definition (fixed in the sequel), and let <span class="math">C<sub>1</sub>,  …, C<sub>k</sub></span> be the set of its triple constraints. The set of triple consumers of  <span class="math">ShDef</span> is composed by the following.
    </p>
    <ul>
      <li><span class="math">TCons<sub>q,C<sub>i</sub></sub></span> for all triple constraint <span class="math">C<sub>i</sub></span> that appears in <span class="math">ShDef</span>, where <span class="math">q</span> is the property, or inverse property, of the triple constraint <span class="math">C<sub>i</sub></span>.</li>
      <li><span class="math">TCons<sub>q,extra</sub></span> for all extra property <span class="math">q</span> in <span class="math">ShDef</span>.</li>
      <li><span class="math">TCons<sub>open</sub></span> which is a special constant.</li>
    </ul>
    
    <p>
      Let <span class="math">Consumers</span> be the set of triple consumers of <span class="math">ShDef</span>. For an edge <span class="math">(node, q, node')</span>, we say that it <span class="emph">matches</span> a triple consumer from <span class="math">Consumers</span> in one of the following situations.
    </p>
    <ul>
      <li>The edge <span class="math">(node, q, node')</span> matches all triple consumer of the form <span class="math">TCons<sub>q,C<sub>i</sub></sub></span>.</li>
      <li>The edge <span class="math">(node, q, node')</span> matches all triple consumer of the form <span class="math">TCons<sub>q,extra</sub></span>.</li>
      <li>The edge <span class="math">(node, q, node')</span> matches the triple consumer <span class="math">TCons<sub>open</sub></span> whenever <span class="math">Consumers</span> does not contain any triple consumer of the form <span class="math">TCons<sub>q,C<sub>i</sub></sub></span> or <span class="math">TCons<sub>q,extra</sub></span> (for the same property or inverse property <span class="math">q</span>).</li>
    </ul>

    <p>
      Consider a set of edges <span class="math">Neigh</span> that corresponds to the neighborhood of some node in some graph. Let <span class="math">witness : Neigh &rarr; Consumers</span> be a total mapping that maps a triple consumer with every edge in <span class="math">Neigh</span>. We say that the mapping <span class="math">witness</span> <span class="emph">is a local witness for the fact that the neighborhood  <span class="math">Neigh</span> satisfies the shape definition <span class="math">ShDef</span></span> if the following are satisfied.
    </p>
    <ul>
      <li>If <span class="math">witness(edge) = TCons</span>, then <span class="math">edge</span> matches <span class="math">TCons</span>.</li>
      <li>If <span class="math">ShDef</span> is forward closed, then there is no forward edge that is mapped with <span class="math">TCons<sub>open</sub></span> by <span class="math">witness</span>.</li>
      <li>If <span class="math">ShDef</span> is inverse closed, then there is no inverse edge that is mapped with <span class="math">TCons<sub>open</sub></span> by <span class="math">witness</span>.</li>
      <li>The set of edges <span class="math">Neigh<sub>expr</sub></span> <span class="emph">satisfies</span> the shape expression of <span class="math">ShDef</span>, where <span class="math">Neigh<sub>expr</sub></span> is the set of edges <span class="math">edge</span> from <span class="math">Neigh</span> such that <span class="math">witness(edge) = TCons<sub>q,C<sub>i</sub></sub></span> for some triple constraint <span class="math">C<sub>i</sub></span> in <span class="math">ShDef</span>.</li>
    </ul>

    <p>
      Finally, we define what it means for a set of neighbourhood edges to satisfy a shape expression. It is parametriezed by a <span class="math">witness</span> mapping. We give a general definition. Let <span class="math">Neigh</span> be a neighbourhood set of edges, <span class="math">Expr</span> be a shape expression, <span class="math">Consumers</span> be the set of triple consumers coming from the triple constraints in  <span class="math">Expr</span>, and let <span class="math">witness : Neigh &rarr; Consumers</span> be a mapping from edges to triple consumers. Then <span class="math">witness</span> is <span class="emph"> is a local witness for the fact that</span> <span class="math">Neig</span> <span class="emph">satisfies</span> <span class="math">Expr</span>, written <span class="math">witness, Neigh &#747; Expr</span>, as defined as follows recursively on the structure of <span class="math">Expr</span>.
    </p>

    <div class="Definition"> 
      <p><span class="math"><span class="textbf">Definition.</span> witness, Neig &#747; Expr</span> holds if:
	<ul>
	  <li><span class="math">Expr = C<sub>i</sub></span> is a triple constraint, <span class="math">Neigh = {edge}</span> is a singleton set, and <span class="math">witness(edge) = C<sub>i</sub></span>.</li>
	  <li><span class="math">Expr = Expr<sub>1</sub> | ... | Expr<sub>k</sub></span> is a some-of shape, and <span class="math">witness, Neigh  &#747; Expr<sub>i</sub></span> for some <span class="math">i</span> in <span class="math">1..k</span>.</li>
	  <li><span class="math">Expr = Expr<sub>1</sub> , ... , Expr<sub>k</sub></span> is a group shape, and for all <span class="math">i</span> in <span class="math">1..k</span>, <span class="math">witness, Neigh<sub>Expr<sub>i</sub>,witness</sub> &#747; Expr<sub>i</sub></span>, and <span class="math">Neigh<sub>Expr<sub>1</sub>,witness</sub> &cup; … &cup; Neigh<sub>Expr<sub>k</sub>,witness</sub> = Neigh</span>, where the sets <span class="math">Neigh<sub>Expr<sub>i</sub>,witness</sub></span> are defined below.</li>
	  <li><span class="math">Expr[min;max]</span> is a repetition shape, and there exists <span class="math">m</span> that belongs to the interval <span class="math">[min;max]</span> s.t. one can split <span class="math">Neigh</span> in  <span class="math">m</span> disjoint sets <span class="math">Neigh<sub>1</sub>,  …, Neigh<sub>m</sub></span> which union is  <span class="math">Neigh</span>, and such that <span class="math">witness, Neigh<sub>i</sub> &#747; Expr</span> for all <span class="math">i</span> in <span class="math">1..m</span>.</li>
	</ul>
	where, <span class="math">Neigh<sub>Expr<sub>i</sub>,witness</sub></span> is the subset of <span class="math">Neigh</span> that contains <span class="math">edge</span> if, and only if, <span class="math">witness(edge) =  TCons<sub>q,C<sub>j</sub></sub></span> for some triple constraint  <span class="math">C<sub>j</sub></span> in <span class="math">Expr</span>.
      </p>
    </div>

    <p>
      In the above definition, for a repetition shape, we required that <span class="math">Neigh</span> is split into <span class="math">m</span> disjoint sets. For <span class="math">m = 0</span>, it is equivalent to <span class="math">Neigh = &empty;</span>.
    </p>

    <h4>Typing of Graph by a Shape Expression Schema</h4>
    <p>
      A shape definition specifies a constraint to be satisfied by the neighbourhood edges of a focus node, but also allows to specify constraints to be satisfied by the neighbour nodes, by referring to other shape definitions, using shape constraints in triple constraints. Thus, the validity of a graph with respect to a shape expression schema is a global property on the graph, and is captured by the notion of valid typing.
    </p>

    <p>
      As previously, we consider a shape expression schema  <span class="mathbf">Sh</span> which set of shape labels is <span class="math">Shapes</span>. The set of shapes negated in <span class="mathbf">Sh</span> is defined as the set of shape names <span class="math">S</span> such that <span class="math">S</span> appears negated in <span class="math">definition(T)</span> for some shape name <span class="math">T</span>. Let <span class="math">NegatedShapes</span> be the set of shape labels of the form <span class="math">!S</span> where <span class="math">S</span> is negated in <span class="mathbf">Sh</span>. That is, <span class="math">NegatedShapes</span> contains all the shapes negated in <span class="mathbf">Sh</span> decorated by a leading <span class="math">!</span> sign.
    </p>

    <p>
      A <span class="emph">typing</span> of a graph <span class="math">G</span> by <span class="mathbf">Sh</span> is a mapping <span class="math">typing : Nodes<sub>G</sub> &rarr; ℙ(Shapes &cup; NegatedShapes)</span> that associates a set of shape names and negated shape names with the nodes of the graph <span class="math">G</span>, and such that a shape name <span class="math">S</span> and its negated variant <span class="math">!S</span> cannot be both associated with the same node. That is, there is no <span class="math">node</span> and no shape name <span class="math">S</span> such that <span class="math">S &in; typing(node)</span> and <span class="math">!S &in; typing(node)</span>. Here, the <span class="math">ℙ</span> symbol is used as power set.
    </p>
    
    <p>
      A typing can be used as a witness that every node in the graph satisfies all the shapes associated with it. This is captured by the notion of <span class="emph">valid typing</span>.
    </p>
    
    <p>
      In the following definition, for a shape label <span class="math">S</span>, <span class="math">Consumers(S)</span> is the set of triple consumers of <span class="math">definition(S)</span>.
    </p>

    <div class="Definition">
      <span class="textbf">Definition (valid typing)</span>
      <p>
	<span class="math">typing</span> is a valid typing if it is a typing, and:
	<dl>
	  <dt><span class="textbf">vt-sat</span></dt>
	  <dd>if <span class="math">S &in; typing(node)</span>, then there exists <span class="math">witness : neigh(node) &rarr; Consumers(S)</span> a local witness for the fact that <span class="math">neigh(n)</span> satisfies <span class="math">definition(S)</span> such that, for all edge <span class="math">(node, q, node')</span> in <span class="math">neigh(node)</span>:
	    <ul>
	      <li>if <span class="math">witness((node, q, node')) = TCons<sub>q,C<sub>i</sub></sub></span> and <span class="math">C<sub>i</sub> = q V</span> for some value set <span class="math">V</span>, then the value of <span class="math">node'</span> belongs to <span class="math">V</span>;
	      </li>
	      <li>if <span class="math">witness((node, q, node')) = TCons<sub>q,C<sub>i</sub></sub></span> and <span class="math">C<sub>i</sub> = q T<sub>1</sub>, …, T<sub>k</sub></span>, then <span class="math">T<sub>j</sub> &in; typing(node')</span> for some shape name <span class="math">T<sub>j</sub></span> among T<sub>1</sub>, …, T<sub>k</sub>;
	      </li>
	      <li>if <span class="math">witness((node, q, node')) = TCons<sub>q,extra</sub></span>, then 
		<ul>
		  <li>for all triple constraint <span class="math">q T<sub>1</sub>, …, T<sub>k</sub></span> in <span class="math">definition(S)</span>, and for all <span class="math">T<sub>j</sub></span> among T<sub>1</sub>, …, T<sub>k</sub>, it is the case that <span class="math">!T<sub>j</sub> &in; typing(node')</span>, and</li>
		  <li>for all triple constraint <span class="math">q V</span> in <span class="math">definition(S)</span>, it is not the case that the value of <span class="math">node'</span> belongs to <span class="math">V;</span></li>
		</ul>
	      </li>
	    </ul>
	  </dd>
	  <dt><span class="textbf">vt-neg</span></dt>
	  <dd>if <span class="math">!S &in; typing(node)</span>, then there does not exist <span class="math">typing'</span> a valid typing such that <span class="math">S &in; typing'(node)</span>.
	  </dd>
	</dl>
      </p>
    </div>

    <p>
      The <span class="textbf">vt-sat</span> requirement intuitively ensures that if a shape name <span class="math">S</span> is associated with a node, then the corresponding shape definition is locally satisfied in that node, and the shape constraints are propagated to its neighbour nodes. The <span class="textbf">vt-neg</span> requirement ensures that a negated shape name is associated with a node only if the node does not satisfy the corresponding (non-negated) shape. Note that the <span class="textbf">vt-sat</span> also enforces that extra properties consume only edges that do not satisfy any of the triple constraints.
    </p>

    <p>
      A typing can also be used as a validation requirement, in order to specify which nodes are expected to satisfy which shapes. Suppose a given <span class="math">typing_requirement</span> which associates shape names or negated shape names with the nodes of a graph. If it is possible to extend <span class="math">typing_requirement</span>, by adding additional shape names to the nodes of the graph, so that the resulting typing is a valid typing, this intuitively captures the fact that for all <span class="math">S &in; typing_requirement(node)</span>, it is the case that the node <span class="math">node</span> satisfies the shape <span class="math">S</span>.
    </p>

    <header>
      <h2>Maximal valid typing</h2>
    </header>
    
    <p>
      For all graph and all shape expression schema, there exists a unique <span class="emph">maximal valid typing</span> that associates with every node all the shape names that are satisfied by this node, and all the negated shape names that are not satisfied by the node. Such a maximal tying can be obtained as follows:
      <ol>
	For all shape name <span class="math">S</span> that appears negated in <span class="mathbf">Sh</span>, and for all <span class="math">node</span> in the graph, associate with <span class="math">node</span> either the type <span class="math">S</span> or the type <span class="math">!S</span>. This is possible because of the well-defined criterion of shape expression schemas. More precisely, it guarantees that shape names that appear negated do not require recursion, and their satisfiability can be checked by exploring only a limited portion of the graph around every node.
      </ol>
      <ol>
	For all shape name <span class="math">S</span> that does not appear negated in <span class="mathbf">Sh</span>, and for all <span class="math">node</span>, add <span class="math">S</span> to the types of <span class="math">node</span>. Then, iteratively remove shape names that are not satisfied the node, until reaching a fixed point (impossible to remove other shape names, because all remaining shape names are satisfied).
      </ol>
    </p>
    
    <p>
      A typing requirement can then be verified by checking whether it is included in the maximal valid typing.
    </p>

    <header>
      <h2>Minimal and Preferred Valid Typings</h2>
    </header>

    <p>
      The maximal valid typing is complex to compute. A more suitable way for verifying a typing requirement is by providing a minimal valid typing that certifies the typing requirement. We now define a notion of minimality that ensures the existence of a unique minimal valid typing. The minimality criterion is based on a total ordering on the edges of an RDF graph. In practice, such total ordering might not exist, but the ORDER BY operator of SPARQL defines a standard partial ordering. Using a partial ordering instead of a total one, there does not exist a unique minimal typing, but one can define a family of <span class="emph">preferred</span> valid typings as a best effort approach. 
    </p>

    <p>
      We next define the unique minimal valid typing, provided a total ordering on the edges of an RDF graph. The family of preferred typings w.r.t. the SPARQL ORDER BY contains exactly the valid typings that are a unique minimal typing for some arbitrary total ordering compatible with the SPARQL ORDER BY partial order.
    </p>
    
    <div class="todo">To be continued</div>
    
    <!-- <p> -->
    <!--   Let <span class="math"><</span> be a total ordering relation on the edges of a graph.  -->
    <!-- </p> -->


    <!-- triple matches constraint -->
    <!-- a matching defines a unique local witness map from triples to triple constraints -->
    <!-- typing propagates a witness -->




<!-- … -->




    <footer>
      <p>
        
      </p>
    </footer>

    <script>
      $("m").wrapInner("<span class='math'/>").children(0).unwrap();
    </script>
  </body>
</html>
